<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>C64 Programmer's Reference Guide</title>
    <link rel="stylesheet" href="assets/main.css" />
    <link href="assets/prism.css" rel="stylesheet" />
  </head>

  <body>
    <div class="navbar">
      <div class="container medium">
        <a href="#menu" class="menu-link">Menu</a>
        <nav id="menu" class="offset" role="navigation">
          <ul>
            <li><a href="index.html">C=</a></li>
          </ul>
        </nav>
      </div>
    </div>
    <div class="container medium">
      <h1>CHAPTER 2</h1>
      <h2>BASIC LANGUAGE VOCABULARY</h2>
      <ul>
        <li><a href="#Introduction">Introduction</a></li>
        <li>
          <a href="#Keywords"
            >BASIC Keywords, Abbreviations, and Function Types</a
          >
        </li>
        <li>
          <a href="#Description">Description of BASIC Keywords (Alpabetical)</a>
        </li>
        <li>
          <a href="#Keyboard">The COMMODORE 64 Keyboard and Features</a>
        </li>
        <li><a href="#Editor">Screen Editor</a></li>
      </ul>
      <h2><a name="Introduction">INTRODUCTION</a></h2>

      <p>
        This chapter explains <i>CBM BASIC Language keywords</i>. First we give
        you an easy to read list of keywords, their abbreviations and what each
        letter looks like on the screen. Then we explain how the syntax and
        operation of each keyword works in detail, and examples are shown to
        give you an idea as to how to use them in your programs.
      </p>
      <p>
        As a convenience, Commodore 64 BASIC allows you to abbreviate most
        keywords. Abbreviations are entered by typing enough letters of the
        keyword to distinguish it from all other keywords, with the last letter
        or graphics entered holding down the <kbd>&lt;SHIFT&gt;</kbd> key.
      </p>
      <p>
        Abbreviations do NOT save any memory when they're used in programs,
        because all keywords are reduced to single-character "tokens" by the
        BASIC Interpreter. When a program containing abbreviations is listed,
        all keywords appear in their fully spelled form. You can use
        abbreviations to put more statements onto a program line even if they
        won't fit onto the 80-character logical screen line. The Screen Editor
        works on an 80-character line. This means that if you use abbreviations
        on any line that goes over 80 characters, you will NOT be able to edit
        that line when <a href="page_058.html#list">LISTed</a>. Instead, what
        you'll have to do is (1) retype the entire line including all
        abbreviations, or (2) break the single line of code into two lines, each
        with its own line number, etc.
      </p>
      <p>
        A complete list of keywords, abbreviations, and their appearance on the
        screen is presented in <a href="page_031.html#2-1">Table 2-1</a>. They
        are followed by an alphabetical description of all the statements,
        commands, and functions available on your Commodore 64.
      </p>
      <p>
        This chapter also explains the BASIC functions built into the BASIC
        Language Interpreter. Built-in functions can be used in direct mode
        statements or in any program, without having to define the function
        further. This is NOT the case with user-defined functions. The results
        of built-in BASIC functions can be used as immediate output or they can
        be assigned to a variable name of an appropriate type. There are two
        types of BASIC functions:
      </p>
      <ol>
        <li>NUMERIC</li>
        <li>STRING</li>
      </ol>
      <p>
        Arguments of built-in functions are always enclosed in parentheses ().
        The parentheses always come directly after the function keyword and NO
        SPACES between the last letter of the keyword and the left parenthesis
        (.
      </p>
      <p>
        The type of argument needed is generally decided by the data type in the
        result. Functions which return a string value as their result are
        identified by having a dollar sign ($) as the last character of the
        keyword. In some cases string functions contain one or more numeric
        argument. Numeric functions will convert between integer and
        floating-point format as needed. In the descriptions that follow, the
        data type of the value returned is shown with each function name. The
        types of arguments are also given with the statement format.
      </p>

      <h3><a name="Keywords">Table 2-1. COMMODORE 64 BASIC KEYWORDS</a></h3>
      <table>
        <tr>
          <th>COMMAND</th>
          <th>ABBREVIATION</th>
          <th>SCREEN</th>
          <th>FUNCTION TYPE</th>
        </tr>
        <tr>
          <td>ABS</td>
          <td><kbd> A &lt;SHIFT&gt; B </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>AND</td>
          <td><kbd> A &lt;SHIFT&gt; N </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>ASC</td>
          <td><kbd> A &lt;SHIFT&gt; S </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>ATN</td>
          <td><kbd> A &lt;SHIFT&gt; T </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>CHR$</td>
          <td><kbd> C &lt;SHIFT&gt; H </kbd></td>
          <td>&nbsp;</td>
          <td>STRING</td>
        </tr>
        <tr>
          <td>CLOSE</td>
          <td><kbd> CL &lt;SHIFT&gt; O </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>CLR</td>
          <td><kbd> C &lt;SHIFT&gt; L </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>CMD</td>
          <td><kbd> C &lt;SHIFT&gt; M </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>CONT</td>
          <td><kbd> C &lt;SHIFT&gt; O </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>COS</td>
          <td>none</td>
          <td>COS</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>DATA</td>
          <td><kbd> D &lt;SHIFT&gt; A </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>DEF</td>
          <td><kbd> D &lt;SHIFT&gt; E </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>DIM</td>
          <td><kbd> D &lt;SHIFT&gt; I </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>END</td>
          <td><kbd> E &lt;SHIFT&gt; N </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>EXP</td>
          <td><kbd> E &lt;SHIFT&gt; X </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>FN</td>
          <td>none</td>
          <td>FN</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>FOR</td>
          <td><kbd> F &lt;SHIFT&gt; O </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>FRE</td>
          <td><kbd> F &lt;SHIFT&gt; R </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>GET#</td>
          <td>none</td>
          <td>GET#</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>GOSUB</td>
          <td><kbd> GO &lt;SHIFT&gt; S </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>GOTO</td>
          <td><kbd> G &lt;SHIFT&gt; O </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>IF</td>
          <td>none</td>
          <td>IF</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>INPUT</td>
          <td>none</td>
          <td>INPUT</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>INPUT#</td>
          <td><kbd> I &lt;SHIFT&gt; N </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>INT</td>
          <td>none</td>
          <td>INT</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>LEFT$</td>
          <td><kbd> LE &lt;SHIFT&gt; F </kbd></td>
          <td>&nbsp;</td>
          <td>STRING</td>
        </tr>
        <tr>
          <td>LEN</td>
          <td>none</td>
          <td>LEN</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>LET</td>
          <td><kbd> L &lt;SHIFT&gt; E </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>LIST</td>
          <td><kbd> L &lt;SHIFT&gt; I </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>LOAD</td>
          <td><kbd> L &lt;SHIFT&gt; O </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>LOG</td>
          <td>none</td>
          <td>LOG</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>MID$</td>
          <td><kbd> M &lt;SHIFT&gt; I </kbd></td>
          <td>&nbsp;</td>
          <td>STRING</td>
        </tr>
        <tr>
          <td>NEW</td>
          <td>none</td>
          <td>NEW</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>NEXT</td>
          <td><kbd> N &lt;SHIFT&gt; E </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>NOT</td>
          <td><kbd> N &lt;SHIFT&gt; O </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>ON</td>
          <td>none</td>
          <td>ON</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>OPEN</td>
          <td><kbd> O &lt;SHIFT&gt; P </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>OR</td>
          <td>none</td>
          <td>OR</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>PEEK</td>
          <td><kbd> P &lt;SHIFT&gt; E </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>POKE</td>
          <td><kbd> P &lt;SHIFT&gt; O </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>POS</td>
          <td>none</td>
          <td>POS</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>PRINT</td>
          <td><kbd> ? </kbd></td>
          <td>?</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>PRINT#</td>
          <td><kbd> P &lt;SHIFT&gt; R </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>READ</td>
          <td><kbd> R &lt;SHIFT&gt; E </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>REM</td>
          <td>none</td>
          <td>REM</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>RESTORE</td>
          <td><kbd> RE &lt;SHIFT&gt; S </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>RETURN</td>
          <td><kbd> RE &lt;SHIFT&gt; T </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>RIGHT$</td>
          <td><kbd> R &lt;SHIFT&gt; I </kbd></td>
          <td>&nbsp;</td>
          <td>STRING</td>
        </tr>
        <tr>
          <td>RND</td>
          <td><kbd> R &lt;SHIFT&gt; N </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>RUN</td>
          <td><kbd> R &lt;SHIFT&gt; U </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>SAVE</td>
          <td><kbd> S &lt;SHIFT&gt; A </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>SGN</td>
          <td><kbd> S &lt;SHIFT&gt; G </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>SIN</td>
          <td><kbd> S &lt;SHIFT&gt; I </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>SPC(</td>
          <td><kbd> S &lt;SHIFT&gt; P </kbd></td>
          <td>&nbsp;</td>
          <td>SPECIAL</td>
        </tr>
        <tr>
          <td>SQR</td>
          <td><kbd> S &lt;SHIFT&gt; Q </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>STATUS</td>
          <td><kbd> ST </kbd></td>
          <td>ST</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>STEP</td>
          <td><kbd> ST &lt;SHIFT&gt; E </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>STOP</td>
          <td><kbd> S &lt;SHIFT&gt; T </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>STR$</td>
          <td><kbd> ST &lt;SHIFT&gt; R </kbd></td>
          <td>&nbsp;</td>
          <td>STRING</td>
        </tr>
        <tr>
          <td>SYS</td>
          <td><kbd> S &lt;SHIFT&gt; Y </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>TAB(</td>
          <td><kbd> T &lt;SHIFT&gt; A </kbd></td>
          <td>&nbsp;</td>
          <td>SPECIAL</td>
        </tr>
        <tr>
          <td>TAN</td>
          <td>none</td>
          <td>TAN</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>THEN</td>
          <td><kbd> T &lt;SHIFT&gt; H </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>TIME</td>
          <td><kbd> TI </kbd></td>
          <td>TI</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>TIME$</td>
          <td><kbd> TI$ </kbd></td>
          <td>TI$</td>
          <td>STRING</td>
        </tr>
        <tr>
          <td>TO</td>
          <td>none</td>
          <td>TO</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>USR</td>
          <td><kbd> U &lt;SHIFT&gt; S </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>VAL</td>
          <td><kbd> V &lt;SHIFT&gt; A </kbd></td>
          <td>&nbsp;</td>
          <td>NUMERIC</td>
        </tr>
        <tr>
          <td>VERIFY</td>
          <td><kbd> V &lt;SHIFT&gt; E </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>WAIT</td>
          <td><kbd> W &lt;SHIFT&gt; A </kbd></td>
          <td>&nbsp;</td>
          <td>&nbsp;</td>
        </tr>
      </table>
      <h2><a name="Description">DESCRIPTION OF BASIC KEYWORDS</a></h2>

      <h3><a name="abs">ABS</a></h3>

      <b
        >TYPE: Function-Numeric<br />
        FORMAT: ABS(&lt;expression&gt;)</b
      >
      <p>
        <b>Action:</b> Returns the absolute value of the number, which is its
        value without any signs. The absolute value of a negative number is that
        number multiplied by -1.
      </p>
      <b>EXAMPLES of ABS Function:</b>
      <pre>
  <code class="language-basic">
    10 X = ABS (Y)
    10 PRINT ABS (X*J)
    10 IF X = ABS (X) THEN PRINT"POSITIVE"
  </code>
</pre>

      <h3><a name="and">AND</a></h3>

      <b
        >TYPE: Operator<br />
        FORMAT: &lt;expression&gt; AND &lt;expression&gt;</b
      >
      <p>
        <b>Action:</b> AND is used in Boolean operations to test bits. it is
        also used in operations to check the truth of both operands. In Boolean
        algebra, the result of an AND operation is 1 only if both numbers being
        ANDed are 1. The result is 0 if either or both is 0 (false).
      </p>

      <b>EXAMPLES of 1-Bit AND operation:</b>
      <pre>
<code class="language-basic">
          0         1         0         1
      AND 0     AND 0     AND 1     AND 1
      ------     -----     -----     -----
          0         0         0         1
</code>
      </pre>
      <p>
        The Commodore 64 performs the AND operation on numbers in the range from
        -32768 to +32767. Any fractional values are not used, and numbers beyond
        the range will cause an
        <b
          ><a href="../Appendices/page_400.html#illegal_quantity"
            >?ILLEGAL QUANTITY</a
          ></b
        >
        error message. When converted to binary format, the range allowed yields
        16 bits for each number. Corresponding bits are ANDed together, forming
        a 16-bit result in the same range.
      </p>
      <b>EXAMPLES of 16-Bit AND Operation:</b>
      <pre>
                                        17
                                   AND 194
                                  --------
                          0000000000010001
                      AND 0000000011000010
                --------------------------
                 (BINARY) 0000000000000000
                --------------------------
                (DECIMAL)                0


                                     32007
                                 AND 28761
                                ----------
                          0111110100000111
                      AND 0111000001011001
                --------------------------
                 (BINARY) 0111000000000001
                --------------------------
                (DECIMAL)            28673


                                      -241
                                 AND 15359
                                ----------
                          1111111100001111
                      AND 0011101111111111
                --------------------------
                 (BINARY) 0011101100001111
                --------------------------
                (DECIMAL)            15119
</pre
      >
      <p>
        When evaluating a number for truth or falsehood, the computer assumes
        the number is true as long as its value isn't 0. When evaluating a
        comparison, it assigns a value of -I if the result is true, while false
        has a value of 0. In binary format, -1 is all 1's and 0 is all 0's.
        Therefore, when ANDing true/false evaluations, the result will be true
        if any bits in the result are true.
      </p>

      <b>EXAMPLES of Using AND with True/False Evaluations:</b>
      <pre>
    <code class="language-basic">
      50 IF X=7 AND W=3 THEN GOTO 10: REM ONLY TRUE IF BOTH X=7
         AND W=3 ARE TRUE
      60 IF A AND Q=7 THEN GOTO 10: REM TRUE IF A IS NON-ZERO
         AND Q=7 IS TRUE
    </code>
</pre>

      <h3><a name="asc">ASC</a></h3>

      <b
        >TYPE: Function-Numeric<br />
        FORMAT: ASC(&lt;string&gt;)</b
      >
      <p>
        <b>Action:</b> ASC will return a number from 0 to 255 which corresponds
        to the Commodore ASCII value of the first character in the string. The
        table of Commodore ASCII values is shown in Appendix C.
      </p>

      <b>EXAMPLES OF ASC Function:</b>
      <pre>
        <code class="language-basic">
          10 PRINT ASC("Z")
          20 X = ASC("ZEBRA")
          30 J = ASC(J$)
        </code>
</pre>
      <p>
        If there are no characters in the string, an
        <b
          ><a href="../Appendices/page_400.html#illegal_quantity"
            >?ILLEGAL QUANTITY</a
          ></b
        >
        error results. In the third example above, if J$="", the ASC function
        will not work. The <a href="page_049.html#get">GET</a> and
        <a href="page_050.html#get">GET#</a> statement read a
        <a href="page_038.html#chr$">CHR$(0)</a> as a null string. To eliminate
        this problem, you should add a
        <a href="page_038.html#chr$">CHR$(0)</a> to the end of the string as
        shown below.
      </p>

      <b
        >EXAMPLE of ASC Function Avoiding
        <a href="../Appendices/page_400.html#illegal_quantity"
          >ILLEGAL QUANTITY ERROR</a
        >:</b
      >
      <pre>
        <code class="language-basic">
          30 J = ASC(J$ + CHR$(0))
        </code>
</pre>
      <h3><a name="atn">ATN</a></h3>

      <b
        >TYPE: Function-Numeric<br />
        FORMAT: ATN(&lt;number&gt;)</b
      >
      <p>
        <b>Action:</b> This mathematical function returns the arctangent of the
        number. The result is the angle (in radians) whose tangent is the number
        given. The result is always in the range -&pi;/2 to +&pi;/2.
      </p>

      <b>EXAMPLES of ATN Function:</b>
      <pre>
        <code class="language-basic">
          10 PRINT ATN(0)
          20 X = ATN(J)*180/&pi; : REM CONVERT TO DEGREES
        </code>
</pre>

      <h3><a name="chr$">CHR$</a></h3>

      <b
        >TYPE: Function-String<br />
        FORMAT: CHR$ (&lt;number&gt;)</b
      >
      <p>
        <b>Action:</b> This function converts a Commodore ASCII code to its
        character equivalent. See Appendix C for a list of characters and their
        codes. The number must have a value between 0 and 255, or an
        <b
          ><a href="../Appendices/page_400.html#illegal_quantity"
            >?ILLEGAL QUANTITY</a
          ></b
        >
        error message results.
      </p>

      <b>EXAMPLES of CHR$ Function:</b>
      <pre>
        <code class="language-basic">
          10 PRINT CHR$(65) : REM 65 = UPPER CASE A
          20 A$=CHR$(13) : REM 13 = RETURN KEY
          50 A=ASC(A$) : A$ = CHR$(A) : REM CONVERTS TO C64 ASCII CODE AND BACK
        </code>
</pre>

      <h3><a name="close">CLOSE</a></h3>

      <b
        >TYPE: I/O Statement<br />
        FORMAT: CLOSE &lt;file number&gt;</b
      >
      <p>
        <b>Action:</b> This statement shuts off any data file or channel to a
        device. The file number is the same as when the file or device was
        <a href="page_065.html#open">OPENed</a> (see
        <a href="page_065.html#open">OPEN statement</a> and
        <a href="../Chapter_6/page_337.html#Output"
          >the section on INPUT/OUTPUT programming</a
        >). When working with storage devices like cassette tape and disks, the
        CLOSE operation stores any incomplete buffers to the device. When this
        is not performed, the file will be incomplete on the tape and unreadable
        on the disk. The CLOSE operation isn't as necessary with other devices,
        but it does free up memory for other files. See your external device
        manual for more details.
      </p>

      <b>EXAMPLES of CLOSE Statement:</b>
      <pre>
        <code class="language-basic">
          10 CLOSE 1
          20 CLOSE X
          30 CLOSE 9*(1+J)
        </code>
</pre>

      <h3><a name="clr">CLR</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: CLR</b
      >
      <p>
        <b>Action:</b> This statement makes available RAM memory that had been
        used but is no longer needed. Any BASIC program in memory is untouched,
        but all variables, arrays,
        <a href="page_051.html#gosub">GOSUB</a> addresses,
        <a href="page_047.html#for">FOR...NEXT</a> loops, user-defined
        functions, and files are erased from memory, and their space is mode
        available to new variables, etc.
      </p>

      <p>
        In the case of files to the disk and cassette tape, they are not
        properly <a href="page_039.html#close">CLOSEd</a> by the CLR statement.
        The information about the files is lost to the computer, including any
        incomplete buffers. The disk drive will still think the file is
        <a href="page_065.html#open">OPEN</a>. See the
        <a href="page_039.html#close">CLOSE</a> statement for more information
        on this.
      </p>

      <b>EXAMPLE of CLR Statement:</b>
      <pre>
        <code class="language-basic">
          10 X=25
          20 CLR
          30 PRINT X
          
          RUN
          0
          
          READY
        </code>
</pre>

      <h3><a name="cmd">CMD</a></h3>

      <b
        >TYPE: I/O Statement<br />
        FORMAT: &lt;file number&gt; [,string]</b
      >
      <p>
        <b>Action:</b> This statement switches the primary- output device from
        the TV screen to the file specified. This file could be on disk, tape,
        printer, or an I/O device like the modem. The file number must be
        specified in a prior <a href="page_065.html#open">OPEN</a> statement.
        The string, when specified, is sent to the file. This is handy for
        titling printouts, etc.
      </p>

      <p>
        When this command is in effect, any
        <a href="page_070.html#print">PRINT</a> statements and
        <a href="page_058.html#list">LIST</a> commands will not display on the
        screen, but will send the text in the same format to the file.
      </p>

      <p>
        To re-direct the output back to the screen, the
        <a href="page_075.html#print">PRINT#</a> command should send a blank
        line to the CMD device before
        <a href="page_039.html#close">CLOSEing</a>, so it will stop expecting
        data (called "un-listening" the device).
      </p>

      <p>
        Any system error (like
        <b
          ><a href="../Appendices/page_400.html#syntax_error"
            >?SYNTAX ERROR</a
          ></b
        >) will cause output to return to the screen. Devices aren't un-listened
        by this, so you should send a blank line after an error condition. (See
        your printer or disk manual for more details.)
      </p>

      <b>EXAMPLES of CMD Statement:</b>
      <pre>
        <code class="language-basic">
          OPEN 4,4: CMD 4,"TITLE" : LIST: REM LISTS PROGRAM ON PRINTER
          PRINT#4: CLOSE 4: REM UN-LISTENS AND CLOSES PRINTER
          
          10 OPEN 1,1,1,"TEST" : REM CREATE SEQ FILE
          20 CMD 1 : REM OUTPUT TO TAPE FILE, NOT SCREEN
          30 FOR L = 1 TO 100
          40 PRINT L: REM PUTS NUMBER IN TAPE BUFFER
          50 NEXT
          60 PRINT#1 : REM UNLISTEN
          70 CLOSE 1 : REM WRITE UNFINISHED BUFFER, PROPERLY FINISH
        </code>
  </pre>

      <h3><a name="cont">CONT</a></h3>

      <b
        >TYPE: Command<br />
        FORMAT: CONT</b
      >

      <p>
        <b>Action:</b> This command re-starts the execution of a program which
        was halted by a <a href="page_086.html#stop">STOP</a> or
        <a href="page_046.html#end">END</a> statement or the
        <kbd>&lt;RUN/STOP&gt;</kbd> key being pressed. The program will re-start
        at the exact place from which it left off. While the program is stopped,
        the user can inspect or change any variables or look at the program.
        When debugging or examining a program,
        <a href="page_086.html#stop">STOP</a> statements can be placed at
        strategic locations to allow examination of variables and to check the
        flow of the program. The error message
        <b
          ><a href="../Appendices/page_400.html#can't_continue"
            >CAN'T CONTINUE</a
          ></b
        >
        will result from editing the program (even just hitting
        <kbd>&lt;RETURN&gt;</kbd> with the cursor on an unchanged line), or if
        the program halted due to an error, or if you caused an error before
        typing CONT to re-start the program.
      </p>

      <b>EXAMPLE of CONT Command:</b>
      <pre>
        <code class="language-basic">
          10 PI=0:C=1
          20 PI=PI+4/C-4/(C+2)
          30 PRINT PI
          40 C=C+4:GOTO 20
        </code>
  </pre>

      <p>
        This program calculates the value of PI. RUN this program, and after a
        short while hit the <kbd>&lt;RUN/STOP&gt;</kbd> key. You will see the
        display:
      </p>

      <pre>
       BREAK IN 20
  </pre
      >
      <table>
        <tr>
          <td><b>NOTE:</b> Might be different number.</td>
        </tr>
      </table>

      <p>
        Type the command PRINT C to see how far the Commodore 64 has gotten.
        Then use CONT to resume from where the Commodore 64 left off.
      </p>

      <h3><a name="cos">COS</a></h3>

      <b
        >TYPE: Function<br />
        FORMAT: COS (&lt;number&gt;)</b
      >

      <p>
        <b>Action:</b> This mathematical function calculates the cosine of the
        number, where the number is an angle in radians.
      </p>

      <b>EXAMPLES of COS Function:</b>
      <pre>
        <code class="language-basic">
          10 PRINT COS(0)
          20 X = COS(Y*&pi;/180) : REM CONVERT DEGREES TO RADIANS
        </code>
  </pre>

      <h3><a name="data">DATA</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: DATA &lt;list of constants&gt;</b
      >

      <p>
        <b>Action:</b> DATA statements store information within a program. The
        program uses the information by means of the
        <a href="page_076.html#read">READ</a> statement, which pulls successive
        constants from the DATA statements.
      </p>
      <p>
        The DATA statements don't have to be executed by the program, they only
        have to be present. Therefore, they are usually placed at the end of the
        program.
      </p>
      <p>
        All data statements in a program are treated as a continuous list. Data
        is <a href="page_076.html#read">READ</a> from left to right, from the
        lowest numbered line to the highest. If the
        <a href="page_076.html#read">READ</a> statement encounters data that
        doesn't fit the type requested (if it needs a number and finds a string)
        an error message occurs.
      </p>

      <p>
        Any characters can be included as data, but if certain ones are used the
        data item must be enclosed by quote marks (" "). These include
        punctuation like comma (,), colon (:), blank spaces, and shifted
        letters, graphics, and cursor control characters.
      </p>

      <b>EXAMPLES of DATA Statement:</b>
      <pre>
        <code class="language-basic">
          10 DATA 1,10,5,8
          20 DATA JOHN,PAUL,GEORGE,RINGO
          30 DATA "DEAR MARY, HOW ARE YOU, LOVE, BILL"
          40 DATA -1.7E-9, 3.33
        </code>
    </pre>
      <h3><a name="def">DEF FN</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: DEF FN &lt;name&gt; ( &lt;variable&gt; ) = &lt;expression&gt;</b
      >
      <p>
        <b>Action:</b> This sets up a user-defined function that can be used
        later in the program. The function can consist of any mathematical
        formula. User-defined functions save space in programs where a long
        formula is used in several places. The formula need only be specified
        once, in the definition statement, and then it is abbreviated as a
        function name. It must be executed once, but any subsequent executions
        are ignored.
      </p>
      <p>
        The function name is the letters
        <a href="../Chapter_2/page_047.html#fn">FN</a> followed by any variable
        name. This can be 1 or 2 characters, the first being a letter and the
        second a letter or digit.
      </p>

      <b>EXAMPLES of DEF FN Statement:</b>
      <pre>
        <code class="language-basic">
          10 DEF FN A(X)=X+7
          20 DEF FN AA(X)=Y*Z
          30 DEF FN A9(Q) = INT(RND(1)*Q+1)
        </code>
    </pre>
      <p>
        The function is called later in the program by using the function name
        with a variable in parentheses. This function name is used like any
        other variable, and its value is automatically calculated.
      </p>

      <b>EXAMPLES of FN Use:</b>
      <pre>
        <code class="language-basic">
          40 PRINT FN A(9)
          50 R=FN AA(9)
          60 G=G+FN A9(10)
        </code>
</pre>
      <p>
        In line 50 above, the number 9 inside the parentheses does not affect
        the outcome of the function, because the function definition in line 20
        doesn't use the variable in the parentheses. The result is Y times Z,
        regardless of the value of X. In the other two functions, the value in
        parentheses does affect the result.
      </p>

      <h3><a name="dim">DIM</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: DIM &lt;variable&gt; ( &lt;subscripts&gt; )[, &lt;variable&gt; (
        &lt;subscripts&gt; )...]
      </b>
      <p>
        <b>Action:</b> This statement defines an array or matrix of variables.
        This allows you to use the variable name with a subscript. The subscript
        points to the element being used. The lowest element number in an array
        is zero, and the highest is the number given in the DIM statement, which
        has a maximum of 32767.
      </p>
      <p>
        The DIM statement must be executed once and only once for each array. A
        <b
          ><a href="../Appendices/page_400.html#redim'd_array"
            >REDIM'D ARRAY</a
          ></b
        >
        error occurs if this line is re-executed. Therefore, most programs
        perform all DIM operations at the very beginning.
      </p>
      <p>
        There may be any number of dimensions and 255 subscripts in an array,
        limited only by the amount of RAM memory which is available to hold the
        variables. The array may be mode up of normal numeric variables, as
        shown above, or of strings or integer numbers. If the variables are
        other than normal numeric, use the $ or % signs after the variable name
        to indicate string or integer variables.
      </p>

      <p>
        If an array referenced in a program was never DiMensioned, it is
        automatically dimensioned to 11 elements in each dimension used in the
        first reference.
      </p>

      <b>EXAMPLES of DIM Statement:</b>
      <pre>
        <code class="language-basic">
          10 DIM A(100)
          20 DIM Z (5,7), Y(3,4,5)
          30 DIM Y7%(Q)
          40 DIM PH$(1000)
          50 F(4)=9 : REM AUTOMATICALLY PERFORMS DIM F(10)
        </code>
</pre>
      <b>EXAMPLE of FOOTBALL SCORE-KEEPING Using DIM:</b>
      <pre>
        <code class="language-basic">
          10 DIM S(1,5), T$(1)
          20 INPUT"TEAM NAMES"; T$(0), T$(1)
          30 FOR Q=1 TO 5: FOR T=0 TO 1
          40 PRINT T$(T),"SCORE IN QUARTER" Q
          50 INPUT S(T,Q): S(T,0)= S(T,0)+ S(T,Q)
          60 NEXT T,Q
          70 PRINT CHR$(147) "SCOREBOARD"
          80 PRINT "QUARTER"
          90 FOR Q= 1 TO 5
          100 PRINT TAB(Q*2+9) Q;
          110 NEXT: PRINT TAB(15) "TOTAL"
          120 FOR T=0 TO 1: PRINT T$(T);
          130 FOR Q= 1 TO 5
          140 PRINT TAB(Q*2+9) S(T,Q);
          150 NEXT: PRINT TAB(15) S(T,0)
          160 NEXT
        </code>
</pre>
      <b>CALCULATING MEMORY USED BY DIM:</b><br />

      5 bytes for the array name<br />
      2 bytes for each dimension<br />
      2 bytes/element for integer variables<br />
      5 bytes/element for normal numeric variables<br />
      3 bytes/element for string variables<br />
      1 byte for each character in each string element<br />
      <br />

      <h3><a name="end">END</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: END</b
      >
      <p>
        <b>Action:</b> This finishes a program's execution and displays the
        READY message, returning control to the person operating the computer.
        There may be any number of
        <a href="page_046.html#end">END</a> statements within a program. While
        it is not necessary to include any
        <a href="page_046.html#end">END</a> statements at all, it is recommended
        that a program does conclude with one, rather than just running out of
        lines.
      </p>
      <p>
        The <a href="page_046.html#end">END</a> statement is similar to the
        <a href="page_086.html#stop">STOP</a> statement. The only difference is
        that <a href="page_086.html#stop">STOP</a> causes the computer to
        display the message
        <b><a href="../Appendices/page_400.html#break">BREAK IN LINE XX</a></b>
        and <a href="page_046.html#end">END</a> just displays READY. Both
        statements allow the computer to resume execution by typing the
        <a href="page_041.html#cont">CONT</a> command.
      </p>

      <b>EXAMPLES of END Statement:</b>
      <pre>
        <code class="language-basic">
          10 PRINT"DO YOU REALLY WANT TO RUN THIS PROGRAM"
          20 INPUT A$
          30 IF A$ = "NO" THEN END
          40 REM REST OF PROGRAM . . .
          999 END
        </code>
</pre>

      <h3><a name="exp">EXP</a></h3>

      <b
        >TYPE: Function-Numeric<br />
        FORMAT: EXP ( &lt;number&gt; )</b
      >
      <p>
        <b>Action:</b> This mathematical function calculates the constant
        <i>e</i> (2.71828183) raised to the power of the number given. A value
        greater than 88.0296919 causes an
        <b><a href="../Appendices/page_400.html#overflow">?OVERFLOW</a></b>
        error to occur.
      </p>

      <b>EXAMPLES of EXP Function:</b>
      <pre>
        <code class="language-basic">
          10 PRINT EXP (1)
          20 X = Y * EXP (Z * Q)
        </code>
          </pre>

      <h3><a name="fn">FN</a></h3>

      <b
        >TYPE: Function-Numeric<br />
        FORMAT: FN &lt;name&gt; ( &lt;number&gt; )</b
      >
      <p>
        <b>Action:</b> This function references the previously
        <a href="page_043.html#def">DEFined</a> formula specified by name. The
        number is substituted into its place (if any) and the formula is
        calculated. The result will be a numeric value.
      </p>
      <p>
        This function can be used in direct mode, as long as the statement
        DEFining it has been executed.
      </p>
      <p>
        If an FN is executed before the
        <a href="page_043.html#def">DEF</a> statement which defines it, an
        <b
          ><a href="../Appendices/page_400.html#undef'd_function"
            >UNDEF'D FUNCTION</a
          ></b
        >
        error occurs.
      </p>

      <b>EXAMPLES of FN (User-Defined) Function:</b>
      <pre>
        <code class="language-basic">
          PRINT FN A(Q)
          1100 J = FN J(7)+ FN J(9)
          9990 IF FN B7 (1+1)= 6 THEN END
        </code>
</pre>

      <h3><a name="for">FOR ... TO ... [STEP ...]</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: FOR &lt;variable&gt; = &lt;start&gt; TO &lt;limit&gt; [ STEP
        &lt;increment&gt; ]</b
      >
      <p>
        <b>Action:</b> This is a special BASIC statement that lets you easily
        use a variable as a counter. You must specify certain parameters: the
        floating-point variable name, its starting value, the limit of the
        count, and how much to add during each cycle.
      </p>

      <p>
        Here is a simple BASIC program that counts from 1 to 10,
        <a href="page_070.html#print">PRINTing</a> each number and
        <a href="page_046.html#end">ENDing</a> when complete, and using no FOR
        statements:
      </p>
      <pre>
        <code class="language-basic">
          100 L = 1
          110 PRINT L
          120 L = 1 + 1
          130 IF L &lt;= 10 THEN 110
          140 END
        </code>
</pre>

      <p>Using the FOR statement, here is the same program:</p>
      <pre>
        <code class="language-basic">
          100 FOR L = 1 TO 10
          110 PRINT L
          120 NEXT L
          130 END
        </code>
</pre>
      <p>
        As you can see, the program is shorter and easier to understand using
        the FOR statement.
      </p>
      <p>
        When the FOR statement is executed, several operations take place. The
        &lt;start&gt; value is placed in the &lt;variable&gt; being used in the
        counter. In the example above, a I is placed in L.
      </p>
      <p>
        When the NEXT statement is reached, the &lt;increment&gt; value is added
        to the &lt;variable&gt;. If a STEP was not included, the
        &lt;increment&gt; is set to + 1. The first time the program above hits
        line 120, 1 is added to L, so the new value of L is 2.
      </p>
      <p>
        Now the value in the &lt;variable&gt; is compared to the &lt;limit&gt;.
        If the &lt;limit&gt; has not been reached yet, the program
        <a href="page_052.html#goto">GOes TO</a> the line after the original FOR
        statement. In this case, the value of 2 in L is less than the limit of
        10, so it <a href="page_052.html#goto">GOes TO</a> line 110.
      </p>
      <p>
        Eventually, the value of &lt;limit&gt; is exceeded by the
        &lt;variable&gt;. At that time, the loop is concluded and the program
        continues with the line following the NEXT statement. In our example,
        the value of L reaches 11, which exceeds the limit of 10, and the
        program goes on with line 130.
      </p>
      <p>
        When the value of &lt;increment&gt; is positive, the &lt;variable&gt;
        must exceed the &lt;limit&gt;, and when it is negative it must become
        less than the &lt;limit&gt;.
      </p>

      <table border="1" cellspacing="0" class="blue" align="center">
        <tr>
          <td><b>NOTE:</b> A loop always executes at least once.</td>
        </tr>
      </table>

      <b>EXAMPLES of FOR...TO...STEP...Statement:</b>
      <pre>
        <code class="language-basic">
          100 FOR L = 100 TO 0 STEP -1
          100 FOR L = PI TO 6* {pi} STEP .01
          100 FOR AA = 3 TO 3
        </code>
</pre>

      <h3><a name="fre">FRE</a></h3>

      <b
        >TYPE: Function<br />
        FORMAT: FRE ( &lt;variable&gt; )</b
      >
      <p>
        <b>Action:</b> This function tells you how much RAM is available for
        your program and its variables. If a program tries to use more space
        than is available, the
        <b
          ><a href="../Appendices/page_400.html#out_of_memory"
            >OUT OF MEMORY</a
          ></b
        >
        error results.
      </p>
      <p>
        The number in parentheses can have any value, and it is not used in the
        calculation.
      </p>

      <table border="1" class="blue" align="center" cellspacing="0">
        <tr>
          <td>
            <b>NOTE:</b> If the result of FRE is negative, add 65536 to the FRE
            number get the number of bytes available in memory.
          </td>
        </tr>
      </table>

      <b>EXAMPLES of FRE Function:</b>
      <pre>
        <code class="language-basic">
          PRINT FRE(0)
          10 X = (FRE(K)-1000)/7
          950 IF FRE(0)&lt; 100 THEN PRINT "NOT ENOUGH ROOM"
        </code>
</pre>

      <p></p>
      <table border="1" class="blue" align="center" cellspacing="0">
        <tr>
          <td>
            <b>NOTE:</b> The following always tells you the current available
            RAM:
            <pre>
              <code class="language-basic">
                PRINT FRE(0) - (FRE(0) &lt; 0)* 65536
              </code>
</pre>
          </td>
        </tr>
      </table>

      <h3><a name="get">GET</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: GET &lt;variable list&gt;</b
      >
      <p>
        <b>Action:</b> This statement reads each key typed by the user. As the
        user is typing, the characters are stored in the Commodore 64's keyboard
        buffer. Up to 10 characters are stored here, and any keys struck after
        the 10th are lost. Reading one of the characters with the GET statement
        makes room for another character.
      </p>
      <p>
        If the GET statement specifies numeric data, and the user types a key
        other than a number, the message
        <b
          ><a href="../Appendices/page_400.html#syntax_error"
            >?SYNTAX ERROR</a
          ></b
        >
        appears. To be safe, read the keys as strings and convert them to
        numbers later.
      </p>
      <p>
        The GET statement can be used to avoid some of the limitations of the
        <a href="page_054.html#input">INPUT</a> statement. For more on this, see
        the section on Using the GET Statement in the Programming Techniques
        section.
      </p>

      <b>EXAMPLES of GET Statement:</b>
      <pre>
        <code class="language-basic">
          10 GET A$: IF A$ ="" THEN 10: REM LOOPS IN 10 UNTIL ANY KEY HIT
          20 GET A$, B$, C$, D$, E$: REM READS 5 KEYS
          30 GET A, A$
        </code>
</pre>

      <h3><a name="get">GET#</a></h3>

      <b
        >TYPE: I/O Statement<br />
        FORMAT: GET# &lt;file number&gt;, &lt;variable list&gt;
      </b>
      <p>
        <b>Action:</b> This statement reads characters one-at-a-time from the
        device or file specified. It works the same as the
        <a href="page_049.html#get">GET</a> statement, except that the data
        comes from a different place than the keyboard. If no character is
        received, the variable is set to an empty string (equal to "") or to 0
        for numeric variables. Characters used to separate data in files, like
        the comma (,) or <kbd>&lt;RETURN&gt;</kbd> key code (ASC code of 13),
        are received like any other character.
      </p>
      <p>
        When used with device #3 (TV screen), this statement will read char-
        acters one by one from the screen. Each use of GET# moves the cursor 1
        position to the right. The character at the end of the logical line is
        changed to a <a href="page_038.html#chr$">CHR$ (13)</a>, the
        <kbd>&lt;RETURN&gt;</kbd> key code.
      </p>

      <b>EXAMPLES of GET# Statement:</b>
      <pre>
        <code class="language-basic">
          5 GET#1, A$
          10 OPEN 1,3: GET#1, Z7$
          20 GET#1, A, B, C$, D$
        </code>
</pre>

      <h3><a name="gosub">GOSUB</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: GOSUB &lt;line number&gt;</b
      >
      <p>
        <b>Action:</b> This is a specialized form of the
        <a href="page_052.html#goto">GOTO</a> statement, with one important
        difference: GOSUB remembers where it came from. When the
        <a href="page_079.html#return">RETURN</a> statement (different from the
        <kbd>&lt;RETURN&gt;</kbd> key on the keyboard) is reached in the
        program, the program jumps back to the statement immediately following
        the original GOSUB statement.
      </p>
      <p>
        The major use of a subroutine (GOSUB really means GO to a SUBroutine) is
        when a small section of program is used by different sections of the
        program. By using subroutines rather than repeating the same lines over
        and over at different places in the program, you can save lots of
        program space. In this way, GOSUB is similar to
        <a href="page_043.html#def">DEF FN</a>.
        <a href="page_043.html#def">DEF FN</a> lets you save space when using a
        formula, while GOSUB saves space when using a several- line routine.
        Here is an inefficient program that doesn't use GOSUB:
      </p>
      <pre>
        <code class="language-basic">
          100 PRINT "THIS PROGRAM PRINTS"
          110 FOR L = 1 TO 500:NEXT
          120 PRINT "SLOWLY ON THE SCREEN"
          130 FOR L = 1 TO 500:NEXT
          140 PRINT "USING A SIMPLE LOOP"
          150 FOR L = 1 TO 500:NEXT
          160 PRINT "AS A TIME DELAY."
          170 FOR L = 1 TO 500:NEXT
        </code>
</pre>
      <p>Here is the same program using GOSUB:</p>
      <pre>
        <code class="language-basic">
          100 PRINT "THIS PROGRAM PRINTS"
          110 GOSUB 200
          120 PRINT "SLOWLY ON THE SCREEN"
          130 GOSUB 200
          140 PRINT "USING A SIMPLE LOOP"
          150 GOSUB 200
          160 PRINT "AS A TIME DELAY."
          170 GOSUB 200
          180 END
          200 FOR L = 1 TO 500 NEXT
          210 RETURN
        </code>
</pre>
      <p>
        Each time the program executes a GOSUB, the line number and position in
        the program line are saved in a special area called the "stack," which
        takes up 256 bytes of your memory. This limits the amount of data that
        can be stored in the stack. Therefore, the number of subroutine return
        addresses that can be stored is limited, and care should be taken to
        make sure every GOSUB hits the corresponding
        <a href="page_079.html#return">RETURN</a>, or else you'll run out of
        memory even though you have plenty of bytes free.
      </p>

      <h3><a name="goto">GOTO</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT :GOTO &lt;line number&gt; or GO TO &lt;line number&gt;</b
      >
      <p>
        <b>Action:</b> This statement allows the BASIC program to execute lines
        out of numerical order. The word GOTO followed by a number will make the
        program jump to the line with that number. GOTO NOT followed by a number
        equals GOTO 0. It must have the line number after the word GOTO.
      </p>
      <p>
        It is possible to create loops with GOTO that will never end. The
        simplest example of this is a line that GOes TO itself, like 10 GOTO 10.
        These loops can be stopped using the <kbd>&lt;RUN/STOP&gt;</kbd> key on
        the keyboard.
      </p>

      <b>EXAMPLES of GOTO Statement:</b>
      <pre>
        <code class="language-basic">
          GOTO 100
          10 GO TO 50
          20 GOTO 999
        </code>
</pre>

      <h3><a name="if">IF...THEN...</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: IF &lt;expression&gt; THEN &lt;line number&gt;<br />
        &nbsp; &nbsp; IF &lt;expression&gt; GOTO &lt;line number&gt;<br />
        &nbsp; &nbsp; IF &lt;expression&gt; THEN &lt;statements&gt;</b
      >
      <p>
        <b>Action:</b> This is the statement that gives BASIC most of its
        "intelligence," the ability to evaluate conditions and take different
        actions depending on the outcome.
      </p>
      <p>
        The word IF is followed by an expression, which can include variables,
        strings, numbers, comparisons, and logical operators. The word THEN
        appears on the same line and is followed by either a line number or one
        or more BASIC statements. When the expression is false, everything after
        the word THEN on that line is ignored, and execution continues with the
        next line number in the program. A true result makes the program either
        branch to the line number after the word THEN or execute whatever other
        BASIC statements are found on that line.
      </p>

      <b>EXAMPLE of IF...GOTO...Statement:</b>
      <pre>
        <code class="language-basic">
          100 INPUT "TYPE A NUMBER"; N
          110 IF N &lt;= 0 GOTO 200
          120 PRINT "SQUARE ROOT=" SQR(N)
          130 GOTO 100
          200 PRINT "NUMBER MUST BE &gt;0"
          210 GOTO 100
        </code>
    </pre>
      <p>
        This program prints out the square root of any positive number. The IF
        statement here is used to validate the result of the
        <a href="page_054.html#input">INPUT</a>. When the result of N &lt;= 0 is
        true, the program skips to line 200, and when the result is false the
        next line to be executed is 120. Note that THEN
        <a href="page_052.html#goto">GOTO</a> is not needed with IF...THEN, as
        in line 110 where <a href="page_052.html#goto">GOTO 200</a> actually
        means THEN <a href="page_052.html#goto">GOTO 200</a>.
      </p>

      <b>EXAMPLE OF IF...THEN...Statement:</b>
      <pre>
        <code class="language-basic">
          100 FOR L = 1 TO 100
          110 IF RND(1) &lt; .5 THEN X=X+1: GOTO 130
          120 Y=Y+1
          130 NEXT L
          140 PRINT "HEADS=" X
          150 PRINT "TAILS= " Y
        </code>
    </pre>
      <p>
        The IF in line 110 tests a random number to see if it is less than .5.
        When the result is true, the whole series of statements following the
        word THEN are executed: first X is incremented by 1, then the program
        skips to line 130. When the result is false, the program drops to the
        next statement, line 120.
      </p>

      <h3><a name="input">INPUT</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: INPUT [ "&lt;prompt&gt;" ; ] &lt;variable list&gt;</b
      >
      <p>
        <b>Action:</b> This is a statement that lets the person
        <a href="page_081.html#run">RUNning</a> the program "feed" information
        into the computer. When executed, this statement
        <a href="page_070.html#print">PRINTs</a> a question mark (?) on the
        screen, and positions the cursor 1 space to the right of the question
        mark. Now the computer waits, cursor blinking, for the operator to type
        in the answer and press the <kbd>&lt;RETURN&gt;</kbd> key.
      </p>
      <p>
        The word <a href="page_054.html#input">INPUT</a> may be followed by any
        text contained in quote marks (""). This text is
        <a href="page_070.html#print">PRINT</a> on the screen, followed by the
        question mark. After the text comes a semicolon (;) and the name of one
        or more variables separated by commas. This variable is where the
        computer stores the information that the operator types. The variable
        can be any legal variable name, and you can have several different
        variable names, each for a different input.
      </p>

      <b>EXAMPLES of INPUT Statement:</b>
      <pre>
        <code class="language-basic">
          100 INPUT A
          110 INPUT B, C, D
          120 INPUT "PROMPT"; E
        </code>
</pre>
      <p>
        When this program <a href="page_081.html#run">RUNs</a>, the question
        mark appears to prompt the operator that the Commodore 64 is expecting
        an input for line 100. Any number typed in goes into A, for later use in
        the program. If the answer typed was not a number, the
        <b
          ><a href="../Appendices/page_400.html#redo_from_start"
            >?REDO FROM START</a
          ></b
        >
        message appears, which means that a string was received when a number
        was expected.
      </p>
      <p>
        If the operator just hits <kbd>&lt;RETURN&gt;</kbd> without typing
        anything, the vari- able's value doesn't change.
      </p>
      <p>
        Now the next question mark, for line 110, appears. If we type only one
        number and hit the <kbd>&lt;RETURN&gt;</kbd>, Commodore 64 will now
        display 2 question marks (??), which means that more input is required.
        You can just type as many inputs as you need separated by commas, which
        prevents the double question mark from appearing. If you type more data
        than the INPUT statement requested, the
        <b
          ><a href="../Appendices/page_400.html#extra_ignored"
            >?EXTRA IGNORED</a
          ></b
        >
        message appears, which means that the extra items you typed were not put
        into any variables.
      </p>
      <p>
        Line 120 displays the word PROMPT before the question mark appears. The
        semicolon is required between the prompt and any list of variables.
      </p>
      <p>
        The INPUT statement can never be used outside a program. The Commodore
        64 needs space for a buffer for the INPUT variables, the same space that
        is used for commands.
      </p>

      <h3><a name="input">INPUT#</a></h3>

      <b
        >TYPE: I/O Statement<br />
        FORMAT: INPUT# &lt;file number&gt; , &lt;variable list&gt;</b
      >
      <p>
        <b>Action:</b> This is usually the fastest and easiest way to retrieve
        data stored in a file on disk or tape. The data is in the form of whole
        variables of up to 80 characters in length, as opposed to the
        one-at-a-time method of <a href="page_050.html#get">GET#</a>. First, the
        file must have been <a href="page_065.html#open">OPENed</a>, then INPUT#
        can fill the variables.
      </p>
      <p>
        The INPUT# command assumes a variable is finished when it reads a RETURN
        code (<a href="page_038.html#chr$">CHR$ (13)</a>), a comma (,),
        semicolon (;), or colon (:). Quote marks can be used to enclose these
        characters when writing if they are needed (see
        <a href="page_075.html#print">PRINT#</a> statement).
      </p>
      <p>
        If the variable type used is numeric, and non-numeric characters are
        received, a
        <b><a href="../Appendices/page_400.html#bad_data">BAD DATA</a></b> error
        results. INPUT# can read strings up to 80 characters long, beyond which
        a
        <b
          ><a href="../Appendices/page_400.html#string_too_long"
            >STRING TOO LONG</a
          ></b
        >
        error results.
      </p>
      <p>
        When used with device #3 (the screen), this statement will read an
        entire logical line and move the cursor down to the next line.
      </p>

      <b>EXAMPLES of INPUT# Statement:</b>
      <pre>
        <code class="language-basic">
          10 INPUT#1,A
          20 INPUT#2,A$,B$
        </code>
</pre>

      <h3><a name="int">INT</a></h3>

      <b
        >TYPE: Integer Function<br />
        FORMAT: INT (&lt;numeric&gt;)</b
      >
      <p>
        <b>Action:</b> Returns the integer value of the expression. If the
        expression is positive, the fractional part is left off. If the
        expression is negative, any fraction causes the next lower integer to be
        returned.
      </p>

      <b>EXAMPLES of INT Function:</b>
      <pre>
        <code class="language-basic">
          120 PRINT INT(99.4343), INT(-12.34)
          
          99       -13
        </code>
</pre>

      <h3><a name="left$">LEFT$</a></h3>

      <b
        >TYPE: String Function<br />
        FORMAT: LEFT$ (&lt;string&gt;, &lt;integer&gt;)</b
      >
      <p>
        <b>Action:</b> Returns a string comprised of the leftmost
        &lt;integer&gt; characters of the &lt;string&gt;. The integer argument
        value must be in the range 0 to 255. If the integer is greater than the
        length of the string, the entire string will be returned. If an
        &lt;integer&gt; value of zero is used, then a null string (of zero
        length) is returned.
      </p>

      <b>EXAMPLES of LEFT$ Function:</b>
      <pre>
        <code class="language-basic">
          10 A$ = "COMMODORE COMPUTERS"
          20 B$ = LEFT$(A$,9): PRINT B$
          RUN
          
          COMMODORE
        </code>
</pre>

      <h3><a name="len">LEN</a></h3>

      <b
        >TYPE: Integer Function<br />
        Format: LEN (&lt;string&gt;)</b
      >
      <p>
        <b>Action:</b> Returns the number of characters in the string
        expression. Non-printed characters and blanks are counted.
      </p>

      <b>EXAMPLE of LEN Function:</b>
      <pre>
        <code class="language-basic">
          CC$ = "COMMODORE COMPUTER": PRINT LEN(CC$)
          
          18
        </code>
</pre>

      <h3><a name="let">LET</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: [LET] &lt;variable&gt; = &lt;expression&gt;</b
      >
      <p>
        <b>Action:</b> The LET statement can be used to assign a value to a
        variable. But the word LET is optional and therefore most advanced
        programmers leave LET out because it's always understood and wastes
        valuable memory. The equal sign (=) alone is sufficient when assigning
        the value of an expression to a variable name.
      </p>

      <b>EXAMPLES of LET Statement:</b>
      <pre>
        <code class="language-basic">
          10 LET D= 12              (This is the same as D = 12)
          20 LET E$ = "ABC"
          30 F$ = "WORDS"
          40 SUM$= E$ + F$          (SUM$ would equal ABCWORDS)
        </code>
</pre>

      <h3><a name="list">LIST</a></h3>

      <b
        >TYPE: Command<br />
        FORMAT: LIST [[&lt;first-line&gt;]-[&lt;last-line&gt;]]</b
      >
      <p>
        <b>Action:</b> The LIST command allows you to look at lines of the BASIC
        program currently in the memory of your Commodore 64. This lets you use
        your computer's powerful screen editor, to edit programs which you've
        LISTed both quickly and easily.
      </p>
      <p>
        The LIST system command displays all or part of the program that is
        currently in memory on the default output device. The LIST will normally
        be directed to the screen and the
        <a href="page_040.html#cmd">CMD</a> statement can be used to switch
        output to an external device such as a printer or a disk. The LIST
        command can appear in a program, but BASIC always returns to the system
        READY message after a LIST is executed.
      </p>
      <p>
        When you bring the program LIST onto the screen, the "scrolling" of the
        display from the bottom of the screen to the top can be slowed by
        holding down the ConTRoL <kbd>&lt;CTRL&gt;</kbd> key. LIST is aborted by
        typing the <kbd>&lt;RUN/STOP&gt;</kbd> key.
      </p>
      <p>
        If no line-numbers are given the entire program is listed. If only the
        first-line number is specified, and followed by a hyphen (-), that line
        and all higher-numbered lines are listed. If only the last line-number
        is specified, and it is preceded by a hyphen, then all lines from the
        beginning of the program through that line are listed. If both numbers
        are specified, the entire range, including the line-numbers LISTed, is
        displayed.
      </p>

      <b>EXAMPLES of LIST Command:</b>
      <pre>
        <code class="language-basic">
          LIST            (Lists the program currently in memory.)
          
          LIST 500        (Lists line 500 only.)
          
          LIST 150-       (Lists all lines from 150 to the end.)
          
          LIST -1000      (Lists all lines from the lowest through 1000.)
          
          LIST 150-1000   (Lists lines 150 through 1000, inclusive.)
          
          10 PRINT "THIS  IS LINE 10"
          20 LIST                             (LIST used in Program Mode)
          30 PRINT "THIS  IS LINE 30"
        </code>
</pre>

      <h3><a name="load">LOAD</a></h3>

      <b
        >TYPE: Command<br />

        FORMAT: LOAD["&lt;file-name&gt;"][,&lt;device&gt;][,&lt;address&gt;]</b
      >
      <p>
        <b>Action:</b> The LOAD statement reads the contents of a program file
        from tape or disk into memory. That way you can use the information
        LOADed or change the information in some way. The device number is
        optional, but when it is left out the computer will automatically
        default to 1, the cassette unit. The disk unit is normally device number
        8. The LOAD closes all open files and, if it is used in direct mode, it
        performs a <a href="page_039.html#clr">CLR</a> (clear) before reading
        the program. If LOAD is executed from within a program, the program is
        <a href="page_081.html#run">RUN</a>. This means that you can use LOAD to
        "chain" several programs together. None of the variables are cleared
        during a chain operation.
      </p>
      <p>
        If you are using file-name pattern matching, the first file which
        matches the pattern is loaded. The asterisk in quotes by itself ("*")
        causes the first file-name in the disk directory to be loaded. if the
        filename used does not exist or if it is not a program file, the BASIC
        error message
        <b
          ><a href="../Appendices/page_400.html#file_not_found"
            >?FILE NOT FOUND</a
          ></b
        >
        occurs.
      </p>
      <p>
        When LOADing programs from tape, the &lt;file-name&gt; can be left out,
        and the next program file on the tape will be read. The Commodore 64
        will blank the screen to the border color after the PLAY key is pressed.
        When the program is found, the screen clears to the background color and
        the "FOUND" message is displayed. When the <kbd>&lt;C=&gt;</kbd> key,
        <kbd>&lt;CTRL&gt;</kbd> key, <kbd>&lt;ARROW LEFT&gt;</kbd> key, or
        <kbd>&lt;SPACE BAR&gt;</kbd> is pressed, the file will be loaded.
        Programs will LOAD starting at memory location 2048 unless a secondary
        &lt;address&gt; of 1 is used. If you use the secondary address of 1 this
        will cause the program to LOAD to the memory location from which it was
        saved.
      </p>

      <b>EXAMPLES of LOAD Command:</b>
      <pre>
        <code class="language-basic">
          LOAD                  (Reads the next program on tape)
                
          LOAD A$               (Uses the name in A$ to search)
                
          LOAD"*",8             (LOADs first program from disk)
                
          LOAD"",1,1            (Looks for the first program on
                                tape, and LOADs it into the same
                                part of memory that it came from)
          
          
          LOAD"STAR TREK"        (LOAD a file from tape)
          PRESS PLAY ON TAPE
          FOUND STAR TREK
          LOADING
          READY.
          
          
          LOAD"FUN",8             (LOAD a file from disk)
          SEARCHING FOR FUN
          LOADING
          READY.
          
          
          LOAD"GAME ONE",8,1       (LOAD a file to the specific
          SEARCHING FOR GAME ONE    memory location from which the
          LOADING                   program was saved on the disk)
          READY.
          
        </code>
          </pre>

      <h3><a name="log">LOG</a></h3>

      <b
        >TYPE: Floating-Point Function<br />
        FORMAT: LOG(&lt;numeric&gt;)</b
      >
      <p>
        <b>Action:</b> Returns the natural logarithm (log to the base of e) of
        the argument. If the value of the argument is zero or negative the BASIC
        error message
        <b
          ><a href="../Appendices/page_400.html#illegal_quantity"
            >?ILLEGAL QUANTITY</a
          ></b
        >
        will occur.
      </p>

      <b>EXAMPLES of LOG Function:</b>
      <pre>
        <code class="language-basic">
          25 PRINT LOG(45/7)
          1.86075234
          
          10 NUM=LOG(ARG)/LOG(10)  (Calculates the LOG of ARG to the base 10)
        </code>
</pre>

      <h3><a name="mid$">MID$</a></h3>

      <b
        >TYPE: String Function<br />
        FORMAT: MID$(&lt;string&gt;,&lt;numeric-1&gt;[,&lt;numeric-2&gt;])</b
      >
      <p>
        <b>Action:</b> The MID$ function returns a sub-string which is taken
        from within a larger &lt;string&gt; argument. The starting position of
        the sub-string is defined by the &lt;numeric-1&gt; argument and the
        length of the sub-string by the &lt;numeric-2&gt; argument. Both of the
        numeric arguments can have values ranging from 0 to 255.
      </p>
      <p>
        If the &lt;numeric-1&gt; value is greater than the length of the
        &lt;string&gt;, or if the &lt;numeric-2&gt; value is zero, then MID$
        gives a null string value. If the &lt;numeric-2&gt; argument is left
        out, then the computer will assume that a length of the rest of the
        string is to be used. And if the source string has fewer characters than
        &lt;numeric-2&gt;, from the starting position to the end of the string
        argument, then the whole rest of the string is used.
      </p>

      <b>EXAMPLE of MID$ Function:</b>
      <pre>
        <code class="language-basic">
          10 A$="GOOD"
          20 B$="MORNING EVENING AFTERNOON"
          30 PRINT A$ + MID$(B$,8,8)
          
          GOOD EVENING
        </code>
</pre>

      <h3><a name="new">NEW</a></h3>

      <b
        >TYPE: Command<br />
        FORMAT: NEW</b
      >
      <p>
        <b>Action:</b> The NEW command is used to delete the program currently
        in memory and clear all variables. Before typing in a new program, NEW
        should be used in direct mode to clear memory. NEW can also be used in a
        program, but you should be aware of the fact that it will erase
        everything that has gone before and is still in the computer's memory.
        This can be particularly troublesome when you're trying to debug your
        program.
      </p>

      <table border="1" cellspacing="0" class="blue" align="center">
        <tr>
          <td>
            <b>BE CAREFUL:</b> Not clearing out an old program before typing a
            new one can result in a confusing mix of the two programs.
          </td>
        </tr>
      </table>

      <b>EXAMPLES of NEW Command:</b>
      <pre>
        <code class="language-basic">
          NEW             (Clears the program and all variables)
          10 NEW          (Performs a NEW operation and STOPs the program.)
        </code>
          </pre>

      <h3><a name="next">NEXT</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: NEXT[&lt;counter&gt;][,&lt;counter&gt;]...</b
      >
      <p>
        <b>Action:</b> The NEXT statement is used with
        <a href="page_047.html#for">FOR</a> to establish the end of a FOR...NEXT
        loop. The NEXT need not be physically the last statement in the loop,
        but it is always the last statement executed in a loop. The
        &lt;counter&gt; is the loop index's variable name used with
        <a href="page_047.html#for">FOR</a> to start the loop. A single NEXT can
        stop several nested loops when it is followed by each
        <a href="page_047.html#for">FOR's</a> &lt;counter&gt; variable name(s).
        To do this each name must appear in the order of inner-most nested loop
        first, to outer-most nested loop last. When using a single NEXT to
        increment and stop several variable names, each variable name must be
        separated by commas. Loops can be nested to 9 levels. If the counter
        variable(s) are omitted, the counter associated with the
        <a href="page_047.html#for">FOR</a> of the current level (of the nested
        loops) is incremented.
      </p>
      <p>
        When the NEXT is reached, the counter value is incremented by 1 or by an
        optional <a href="page_047.html#for">STEP</a> value. It is then tested
        against an end-value to see if it's time to stop the loop. A loop will
        be stopped when a NEXT is found which has its counter value greater than
        the end-value.
      </p>

      <b>EXAMPLES of NEXT Statement:</b>
      <pre>
        <code class="language-basic">
          10 FOR J=1 TO 5: FOR K=10 TO 20: FOR N=5 TO -5 STEP - 1
          
          20 NEXT N,K,J            (Stopping Nested Loops)
          
          
          10 FOR L=1 TO 100
          20 FOR M=1 TO 10
          30 NEXT M
          400 NEXT L               (Note how the loops do NOT cross each other)
          
          
          10 FOR A=1 TO 10
          20 FOR B=1 TO 20
          30 NEXT
          40 NEXT                  (Notice that no variable names are needed)
        </code>
</pre>

      <h3><a name="not">NOT</a></h3>

      <b
        >TYPE: Logical Operator<br />
        FORMAT: NOT &lt;expression&gt;</b
      >
      <p>
        <b>Action:</b> The NOT logical operator "complements" the value of each
        bit in its single operand, producing an integer "twos-complement"
        result. In other words, the NOT is really saying, "if it isn't. When
        working with a floating-point number, the operands are converted to
        integers and any fractions are lost. The NOT operator can also be used
        in a comparison to reverse the true/false value which was the result of
        a relationship test and therefore it will reverse the meaning of the
        comparison. In the first example below, if the "twos-complement" of "AA"
        is equal to "BB" and if "BB" is NOT equal to "CC" then the expression is
        true.
      </p>
      <b>EXAMPLES of NOT Operator:</b>
      <pre>
        <code class="language-basic">
          10 IF NOT AA = BB AND NOT(BB = CC) THEN...
          
          NN% = NOT 96: PRINT NN%
          -97
        </code>
</pre>

      <table border="1" class="blue" cellspacing="0" align="center">
        <tr>
          <td>
            <b>NOTE:</b> TO find the value of NOT use the expression X=(-(X+1)).
            (The two's complement of any integer is the bit complement plus
            one.)
          </td>
        </tr>
      </table>

      <h3><a name="on">ON</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: ON &lt;variable&gt; GOTO / GOSUB
        &lt;line-number&gt;[,&lt;line-number&gt;]...</b
      >
      <p>
        <b>Action:</b> The ON statement is used to
        <a href="page_052.html#goto">GOTO</a> one of several given linenumbers,
        depending upon the value of a variable. The value of the variables can
        range from zero through the number of lines given. if the value is a
        non-integer, the fractional portion is left off. For example, if the
        variable value is 3, ON will <a href="page_052.html#goto">GOTO</a> the
        third line-number in the list.
      </p>
      <p>
        If the value of the variable is negative, the BASIC error message
        <b
          ><a href="../Appendices/page_400.html#illegal_quantity"
            >?ILLEGAL QUANTITY</a
          ></b
        >
        occurs. If the number is zero, or greater than the number of items in
        the list, the program just "ignores" the statement and continues with
        the statement following the ON statement.
      </p>
      <p>
        ON is really an underused variant of the
        <a href="page_052.html#if">IF...THEN...</a> statement. Instead of using
        a whole lot of <a href="page_052.html#if">IF</a> statements each of
        which sends the program to 1 specific line, 1 ON statement can replace a
        list of <a href="page_052.html#if">IF</a> statements. When you look at
        the first example you should notice that the 1 ON statement replaces 4
        <a href="page_052.html#if">IF...THEN...</a> statements.
      </p>

      <b>EXAMPLES of ON Statement:</b>
      <pre>
        <code class="language-basic">
          ON -(A=7)-2*(A=3)-3*(A&lt;3)-4*(A&gt;7)GOTO 400,900,1000,100
          ON X GOTO 100,130,180,220
          ON X+3 GOSUB 9000,20,9000
          100 ON NUM GOTO 150,300,320,390
          500 ON SUM/2 + 1 GOSUB 50,80,20
        </code>
</pre>

      <h3><a name="open">OPEN</a></h3>

      <b
        >TYPE: I/O Statement<br />
        FORMAT: OPEN &lt;file-num&gt;,[&lt;device&gt;][,&lt;address&gt;]
        [,"&lt;File-name&gt; [,&lt;type&gt;] [,&lt;mode&gt;]"]</b
      >
      <p>
        <b>Action:</b> This statement OPENs a channel for input and/or output to
        a peripheral device. However, you may NOT need all those parts for every
        OPEN statement. Some OPEN statements require only 2 codes:
      </p>

      <ol>
        <li>LOGICAL FILE NUMBER</li>
        <li>DEVICE NUMBER</li>
      </ol>

      <p>
        The &lt;file-num&gt; is the logical file number, which relates the OPEN,
        <a href="page_039.html#close">CLOSE</a>,
        <a href="page_040.html#cmd">CMD</a>,
        <a href="page_050.html#get">GET#</a>,
        <a href="page_055.html#input">INPUT#</a>, and
        <a href="page_075.html#print">PRINT#</a> statements to each other and
        associates them with the file-name and the piece of equipment being
        used. The logical file number can range from 1 to 255 and you can assign
        it any number you want in that range.
      </p>

      <table border="1" cellspacing="0" class="blue" align="center">
        <tr>
          <td>
            <b>NOTE:</b> File numbers over 128 were really designed for other
            uses so it's good practice to use only numbers below 127 for file
            numbers.
          </td>
        </tr>
      </table>

      <p>
        Each peripheral device (printer, disk drive, cassette) in the system has
        its own number which it answers to. The &lt;device&gt; number is used
        with OPEN to specify on which device the data file exists. Peripherals
        like cassette decks, disk drives or printers also answer to several
        secondary addresses. Think of these as codes which tell each device what
        operation to perform. The device logical file number is used with every
        <a href="page_050.html#get">GET#</a>,
        <a href="page_055.html#input">INPUT#</a>, and
        <a href="page_075.html#print">PRINT#</a>.
      </p>
      <p>
        If the &lt;device&gt; number is left out the computer will automatically
        assume that you want your information to be sent to and received from
        the Datassette<sup><small>TM</small></sup
        >, which is device number 1. The file-name can also be left out, but
        later on in your program, you can NOT call the file by name if you have
        not already given it one. When you are storing files on cassette tape,
        the computer will assume that the secondary &lt;address&gt; is zero (0)
        if you omit the secondary address (a READ operation).
      </p>

      <p>
        A secondary address value of one (1) OPENs cassette tape files for
        writing. A secondary address value of two (2) causes an end-of-tape
        marker to be written when the file is later closed. The end-of-tape
        marker prevents accidentally reading past the end of data which results
        in the BASIC error message
        <b
          ><a href="../Appendices/page_400.html#device_not_present"
            >?DEVICE NOT PRESENT</a
          ></b
        >.
      </p>
      <p>
        For disk files, the secondary addresses 2 thru 14 are available for
        data-files, but other numbers have special meanings in DOS commands. You
        must use a secondary address when using your disk drive(s). (See your
        disk drive manual for DOS command details.)
      </p>
      <p>
        The &lt;file-name&gt; is a string of 1-16 characters and is optional for
        cassette or printer files. If the file &lt;type&gt; is left out the type
        of file will automatically default to the Program file unless the
        &lt;mode&gt; is given. <i>Sequential</i> files are OPENed for reading
        &lt;mode&gt;=R unless you specify that files should be OPENed for
        writing &lt;mode&gt; =W is specified. A file &lt;type&gt; can be used to
        OPEN an existing Relative file. Use REL for &lt;type&gt; with Relative
        files. Relative and Sequential files are for disk only.
      </p>
      <p>
        If you try to access a file before it is OPENed the BASIC error message
        <b
          ><a href="../Appendices/page_400.html#file_not_open"
            >?FILE NOT OPEN</a
          ></b
        >
        will occur. If you try to OPEN a file for reading which does not exist
        the BASIC error message
        <b
          ><a href="../Appendices/page_400.html#file_not_found"
            >?FILE NOT FOUND</a
          ></b
        >
        will occur. If a file is OPENed to disk for writing and the file-name
        already exists, the DOS error message <b>FILE EXISTS</b> occurs. There
        is no check of this type available for tape files, so be sure that the
        tape is properly positioned or you might accidentally write over some
        data that had previously been <a href="page_081.html#save">SAVEd</a>. If
        a file is OPENed that is already OPEN, the BASIC error message
        <b><a href="../Appendices/page_400.html#file_open">FILE OPEN</a></b>
        occurs. (See Printer Manual for further details.)
      </p>

      <b>EXAMPLES of OPEN Statements:</b>

      <pre>
        <code class="language-basic">
          10 OPEN 2,8,4,"DISK-OUTPUT,SEQ,W"  (Opens sequential file on disk)
          
          10 OPEN 1,1,2,"TAPE-WRITE"         (Write End-of-File on Close)
          
          10 OPEN 50,0                       (Keyboard input)
          
          10 OPEN 12,3                       (Screen output)
          
          10 OPEN 130,4                      (Printer output)
          
          10 OPEN 1,1,0,"NAME"               (Read from cassette)
          
          10 OPEN 1,1,1,"NAME"               (Write to cassette)
          
          10 OPEN 1,2,0,CHR$(10)             (open channel to RS-232 device)
          
          10 OPEN 1,4,0,"STRING"             (Send upper case/graphics to
          the printer)
          
          10 OPEN 1,4,7,"STRING"             (Send upper/lower case to
          printer)
          
          10 OPEN 1,5,7,"STRING"             (Send upper/lower case to
          printer with device # 5)
          
          10 OPEN 1,8,15,"COMMAND"           (Send a command to disk)
          
        </code>
          </pre>

      <h3><a name="or">OR</a></h3>

      <b
        >TYPE: Logical Operator<br />
        FORMAT: &lt;operand&gt; OR &lt;operand&gt;
      </b>
      <p>
        <b>Action:</b> Just as the relational operators can be used to make
        decisions regarding program flow, logical operators can connect two or
        more re- lations and return a true or false value which can then be used
        in a decision. When used in calculations, the logical OR gives you a bit
        result of I if the corresponding bit of either or both operands is 1.
        This will produce an integer as a result depending on the values of the
        operands. When used in comparisons the logical OR operator is also used
        to link two expressions into a single compound expression. If either of
        the expressions are true, the combined expression value is true (-1). In
        the first example below if AA is equal to BB OR if XX is 20, the
        expression is true.
      </p>
      <p>
        Logical operators work by converting their operands to 16-bit, signed,
        two's complement integers in the range of -32768 to +32767. If the
        operands are not in the range an error message results. Each bit of the
        result is determined by the corresponding bits in the two operands.
      </p>
      <b>EXAMPLES of OR Operator:</b>

      <pre>
        <code class="language-basic">
          100 IF (AA=BB) OR (XX=20) THEN...
          
          230 KK%=64 OR 32: PRINT KK%         (You typed this with a bit
          value of 1000000 for 64
          and 100000 for 32)
          
          96                                  (The computer responded with
          bit value 1100000.
          1100000=96.)
        </code>
</pre>

      <h3><a name="peek">PEEK</a></h3>

      <b
        >TYPE: Integer Function<br />
        FORMAT: PEEK(&lt;numeric&gt;)</b
      >
      <p>
        <b>Action:</b> Returns an integer in the range of 0 to 255, which is
        read from a memory location. The &lt;numeric&gt; expression is a memory
        location which must be in the range of 0 to 65535. If it isn't then the
        BASIC error message
        <b
          ><a href="../Appendices/page_400.html#illegal_quantity"
            >?ILLEGAL QUANTITY</a
          ></b
        >
        occurs.
      </p>

      <b>EXAMPLES of PEEK Function:</b>
      <pre>
        <code class="language-basic">
          10 PRINT PEEK(53280) AND 15   (Returns value of screen border color)
          
          5 A%=PEEK(45)+PEEK(46)*256    (Returns address of BASIC variable table)
        </code>
</pre>

      <h3><a name="poke">POKE</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: POKE &lt;location&gt;,&lt;value&gt;</b
      >
      <p>
        <b>Action:</b> The POKE statement is used to write a one-byte (8-bits)
        binary value into a given memory location or input/output register. The
        &lt;location&gt; is an arithmetic expression which must equal a value in
        the range of 0 to 65535. The &lt;value&gt; is an expression which can be
        reduced to an integer value of 0 to 255. If either value is out of its
        respective range, the BASIC error message
        <b
          ><a href="../Appendices/page_400.html#illegal_quantity"
            >?ILLEGAL QUANTITY</a
          ></b
        >
        occurs.
      </p>
      <p>
        The POKE statement and <a href="#peek">PEEK</a> statement (which is a
        built-in function that looks at a memory location) are useful for data
        storage, controlling graphics displays or sound generation, loading
        assembly language sub- routines, and passing arguments and results to
        and from assembly language subroutines. In addition, Operating System
        parameters can be examined using <a href="#peek">PEEK</a> statements or
        changed and manipulated using POKE statements. A complete memory map of
        useful locations is given in
        <a href="../Appendices/page_391.html">Appendix G</a>.
      </p>

      <b>EXAMPLES of POKE Statement:</b>
      <pre>
        <code class="language-basic">
          POKE 1024, 1         (Puts an "A" at position 1 on the screen)
          POKE 2040, PTR       (Updates Sprite #0 data pointer)
          10 POKE RED,32
          20 POKE 36879,8
          2050 POKE A,B
        </code>
</pre>

      <h3><a name="pos">POS</a></h3>

      <b
        >TYPE: Integer Function<br />
        FORMAT: POS (&lt;dummy&gt;)</b
      >
      <p>
        <b>Action:</b> Tells you the current cursor position which, of course,
        is in the range of 0 (leftmost character) though position 79 on an
        80-character logical screen line. Since the Commodore 64 has a 40-column
        screen, any position from 40 through 79 will refer to the second screen
        line. The dummy argument is ignored.
      </p>

      <b>EXAMPLE of POS Function:</b>
      <pre>
        <code class="language-basic">
          1000 IF POS(0)&gt;38 THEN PRINT CHR$(13)
        </code>
</pre>

      <h3><a name="print">PRINT</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: PRINT [&lt;variable&gt;][&lt;,/;&gt;&lt;variable&gt;]...</b
      >
      <p>
        <b>Action:</b> The PRINT statement is normally used to write data items
        to the screen. However, the
        <a href="page_040.html#cmd">CMD</a> statement may be used to re-direct
        that output to any other device in the system. The &lt;variable(s)&gt;
        in the output-list are expressions of any type. If no output-list is
        present, a blank line is printed. The position of each printed item is
        determined by the punctuation used to separate items in the output-list.
      </p>
      <p>
        The punctuation characters that you can use are blanks, commas, or
        semicolons. The 80-character logical screen line is divided into 8 print
        zones of 10 spaces each. In the list of expressions, a comma causes the
        next value to be printed at the beginning of the next zone. A semicolon
        causes the next value to be printed immediately following the previous
        value. However, there are two exceptions to this rule:
      </p>

      <p>
        1) Numeric items are followed by an added space.<br />
        2) Positive numbers have a space preceding them.
      </p>

      <p>
        When you use blanks or no punctuation between string constants or
        variable names it has the same effect as a semicolon. However, blanks
        between a string and a numeric item or between two numeric items will
        stop output without printing the second item.
      </p>
      <p>
        If a comma or a semicolon is at the end of the output-list, the next
        PRINT statement begins printing on the same line, and spaced accord-
        ingly. If no punctuation finishes the list, a carriage-return and a
        line- feed are printed at the end of the data. The next PRINT statement
        will begin on the next line. If your output is directed to the screen
        and the data printed is longer than 40 columns, the output is continued
        on the next screen line.
      </p>
      <p>
        There is no statement in BASIC with more variety than the PRINT
        statement. There are so many symbols, functions, and parameters
        associated with this statement that it might almost be considered as a
        language of its own within BASIC; a language specially designed for
        writing on the screen.
      </p>

      <b>EXAMPLES of PRINT Statement:</b>
      <pre>
        <code class="language-basic">
          1)
          5 X = 5
          10 PRINT -5*X,X-5,X+5,X^5
          
          -25     0     10     3125
          
          
          2)
          5 X=9
          10 PRINT X;"SQUARED IS";X*X;"AND";
          20 PRINT X "CUBED IS" X^3
          
          9 SQUARED IS 81 AND 9 CUBED IS 729
          
          
          3)
          90 AA$="ALPHA":BB$="BAKER":CC$="CHARLIE":DD$="DOG":EE$="ECHO"
          100 PRINT AA$BB$;CC$ DD$,EE$
          
          ALPHABAKERCHARLIEDOG     ECHO
        </code>
          </pre>

      <p>
        The <kbd>&lt;SHIFT&gt; &lt;RETURN&gt;</kbd> will work in the
        <a href="page_058.html#list">LISTing</a> as well as PRINTing, so editing
        will be almost impossible if this character is used. The
        <a href="page_058.html#list">LISTing</a> will also look very strange.
      </p>

      <h3><a name="print">PRINT#</a></h3>

      <b
        >TYPE: I/O Statement<br />
        FORMAT:
        PRINT#&lt;file-number&gt;[&lt;variable&gt;][&lt;,/;&gt;&lt;variable&gt;]...
      </b>

      <p>
        <b>Actions:</b> The PRINT# statement is used to write data items to a
        logical file. It must use the same number used to
        <a href="page_065.html#open">OPEN</a> the file. Output goes to the
        device-number used in the
        <a href="page_065.html#open">OPEN</a> statement. The &lt;variable&gt;
        expressions in the output-list can be of any type. The punctuation
        characters between items are the same as with the
        <a href="page_070.html#print">PRINT</a> statement and they can be used
        in the same ways. The effects of punctuation are different in two
        significant respects.
      </p>

      <p>
        When PRINT# is used with tape files, the comma, instead of spacing by
        print zones, has the same effect as a semicolon. Therefore, whether
        blanks, commas, semicolons or no punctuation characters are used between
        data items, the effect on spacing is the same. The data items are
        written as a continuous stream of characters. Numeric items are followed
        by a space and, if positive, are preceded by a space.
      </p>

      <p>
        If no punctuation finishes the list, a carriage-return and a line-feed
        are written at the end of the data. If a comma or semicolon terminates
        the output-list, the carriage-return and line-feed are suppressed.
        Regardless of the punctuation, the next PRINT# statement begins output
        in the next available character position. The line-feed will act as a
        stop when using the <a href="page_055.html#input">INPUT#</a> statement,
        leaving an empty variable when the next
        <a href="page_055.html#input">INPUT#</a> is executed. The line-feed can
        be suppressed or compensated for as shown in the examples below.
      </p>
      <p>
        The easiest way to write more than one variable to a file on tape or
        disk is to set a string variable to
        <a href="page_038.html#chr$">CHR$(13)</a>, and use that string in
        between all the other variables when writing the file.
      </p>

      <b>EXAMPLES of PRINT# Statement:</b>

      <pre>
        <code class="language-basic">
          1)
         
            10 OPEN 1,1,1,"TAPE FILE"
            20 R$=CHR$(13)                      (By Changing the CHR$(13) to
            30 PRINT#1,1;R$;2;R$;3;R$;4;R$;5     CHR$(44) you put a "," between
            40 PRINT#1,6                         each variable. CHR$(59) would
            50 PRINT# 1,7                        put a ";" between each variable.)
         
         
          2)
         
            10 CO$=CHR$(44):CR$=CHR$(13)
            20 PRINT#1,"AAA"CO$"BBB",           AAA,BBB     CCCDDDEEE
               "CCC";"DDD";"EEE"CR$             (carriage return)
               "FFF"CR$;                        FFF(carriage return)
            30 INPUT#1,A$,BCDE$,F$
         
          3)
         
             5 CR$=CHR$(13)
            10 PRINT#2,"AAA";CR$;"BBB"          (10 blanks) AAA
            20 PRINT#2,"CCC";                   BBB
                                                (10 blanks)CCC
            30 INPUT#2,A$,B$,DUMMY$,C$
        </code>
</pre>

      <h3><a name="read">READ</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: READ &lt;variable&gt;[,&lt;variable&gt;]...</b
      >
      <p>
        <b>Action:</b> The READ statement is used to fill variable names from
        constants in <a href="page_042.html#def">DATA</a> statements. The data
        actually read must agree with the variable types specified or the BASIC
        error message
        <b
          ><a href="../Appendices/page_400.html#syntax_error"
            >?SYNTAX ERROR</a
          ></b
        >
        will result.<sup><a href="page_077.html#note">*</a></sup> Variables in
        the <a href="page_042.html#def">DATA</a> input-list must be separated by
        commas.
      </p>
      <p>
        A single READ statement can access one or more DATA statements, which
        will be accessed in order (see <a href="page_042.html#def">DATA</a>), or
        several READ statements can access the same
        <a href="page_042.html#def">DATA</a> statement. If more READ statements
        are executed than the number of elements in
        <a href="page_042.html#def">DATA</a> statements(s) in the program, the
        BASIC error message
        <b
          ><a href="../Appendices/page_400.html#out_of_data">?OUT OF DATA</a></b
        >
        is printed. If the number of variables specified is fewer than the
        number of elements in the
        <a href="page_042.html#def">DATA</a> statement(s), subsequent READ
        statements will continue reading at the next data element. (See
        <a href="page_078.html#restore">RESTORE</a>.)
      </p>

      <table border="1" cellspacing="0" class="blue" align="center">
        <tr>
          <td>
            <a name="note">*</a><b>NOTE:</b> The <b>?SYNTAX ERROR</b> will
            appear with the line number from the DATA statement, NOT the READ
            statement.
          </td>
        </tr>
      </table>

      <b>EXAMPLES of READ Statement:</b>
      <pre>
        <code class="language-basic">
          110 READ A,B,C$
          120 DATA 1,2,HELLO
       
          100 FOR X=1 TO 10: READ A(X):NEXT
       
          200 DATA 3.08, 5.19, 3.12, 3.98, 4.24
          210 DATA 5.08, 5.55, 4.00, 3.16, 3.37
       
          (Fills array items (line 1) in order of constants shown (line 5))
       
          1 READ CITY$,STATE$,ZIP
          5 DATA DENVER,COLORADO, 80211
        </code>
</pre>

      <h3><a name="rem">REM</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: REM [&lt;remark&gt;]</b
      >
      <p>
        <b>Action:</b>The REM statement makes your programs more easily
        understood when <a href="page_058.html#list">LISTed</a>. It's a reminder
        to yourself to tell you what you had in mind when you were writing each
        section of the program. For instance, you might want to remember what a
        variable is used for, or some other useful information. The REMark can
        be any text, word, or character including the colon (:) or BASIC
        keywords.
      </p>
      <p>
        The REM statement and anything following it on the same line-number are
        ignored by BASIC, but REMarks are printed exactly as entered when the
        program is listed. A REM statement can be referred to by a
        <a href="page_052.html#goto">GOTO</a> or
        <a href="page_051.html#gosub">GOSUB</a> statement, and the execution of
        the program will continue with the next higher program line having
        executable statements.
      </p>

      <b>EXAMPLES of REM Statement:</b>
      <pre>
        <code class="language-basic">
          10 REM CALCULATE AVERAGE VELOCITY
          20 FOR X= 1 TO 20 :REM LOOP FOR TWENTY VALUES
          30 SUM=SUM + VEL(X): NEXT
          40 AVG=SUM/20
        </code>
</pre>

      <h3><a name="restore">RESTORE</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: RESTORE
      </b>
      <p>
        <b>Action:</b> BASIC maintains an internal pointer to the next
        <a href="page_042.html#def">DATA</a> constant to be
        <a href="page_076.html#read">READ</a>. This pointer can be reset to the
        first <a href="page_042.html#def">DATA</a> constant in a program using
        the RESTORE statement. The RESTORE statement can be used anywhere in the
        program to begin <a href="page_076.html#read">re-READing</a>
        <a href="page_042.html#def">DATA</a>.
      </p>

      <b>EXAMPLES of RESTORE Statement:</b>
      <pre>
        <code class="language-basic">
          100 FOR X=1 TO 10: READ A(X): NEXT
          200 RESTORE
          300 FOR Y=1 TO 10: READ B(Y): NEXT
       
          4000 DATA 3.08, 5.19, 3.12, 3.98, 4.24
          4100 DATA 5.08, 5.55, 4.00, 3.16, 3.37
       
          (Fills the two arrays with identical data)
       
          10 DATA 1,2,3,4
          20 DATA 5,6,7,8
          30 FOR L= 1 TO 8
          40 READ A: PRINT A
          50 NEXT
          60 RESTORE
          70 FOR L= 1 TO 8
          80 READ A: PRINT A
          90 NEXT
        </code>
</pre>

      <h3><a name="return">RETURN</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: RETURN</b
      >
      <p>
        <b>Action:</b> The RETURN statement is used to exit from a subroutine
        called for by a <a href="page_051.html#gosub">GOSUB</a> statement.
        RETURN restarts the rest of your program at the next executable
        statement following the <a href="page_051.html#gosub">GOSUB</a>. If you
        are nesting subroutines, each
        <a href="page_051.html#gosub">GOSUB</a> must be paired with at least one
        RETURN statement. A subroutine can contain any number of RETURN
        statements, but the first one encountered will exit the subroutine.
      </p>

      <b>EXAMPLE of RETURN Statement:</b>
      <pre>
        <code class="language-basic">
          10 PRINT"THIS IS THE PROGRAM"
          20 GOSUB 1000
          30 PRINT"PROGRAM CONTINUES"
          40 GOSUB 1000
          50 PRINT"MORE PROGRAM"
          60 END
          1000 PRINT"THIS IS THE GOSUB":RETURN
        </code>
</pre>

      <h3><a name="right$">RIGHT$</a></h3>

      <b
        >TYPE: String Function<br />
        FORMAT: RIGHT$ (&lt;string&gt;,&lt;numeric&gt;)</b
      >
      <p>
        <b>Action:</b> The RIGHT$ function returns a sub-string taken from the
        rightmost end of the &lt;string&gt; argument. The length of the
        sub-string is defined by the &lt;numeric&gt; argument which can be any
        integer in the range of 0 to 255. If the value of the numeric expression
        is zero, then a null string ("") is returned. If the value you give in
        the &lt;numeric&gt; argument is greater than the length of the
        &lt;string&gt; then the entire string is returned.
      </p>

      <b>EXAMPLE of RIGHT$ Function:</b>
      <pre>
        <code class="language-basic">
          10 MSG$="COMMODORE COMPUTERS"
          20 PRINT RIGHT$(MSG$,9)
          RUN
       
          COMPUTERS
        </code>
</pre>

      <h3><a name="rnd">RND</a></h3>

      <b
        >TYPE: Floating-Point Function<br />
        FORMAT: RND (&lt;numeric&gt;)</b
      >
      <p>
        <b>Action:</b> RND creates a floating-point random from 0.0 to 1.0. The
        computer generates a sequence of random numbers by performing
        calculations on a starting number, which in computer jargon is called a
        seed. The RND function is seeded on system power-up. The &lt;numeric&gt;
        argument is a dummy, except for its sign (positive, zero, or negative).
      </p>
      <p>
        If the &lt;numeric&gt; argument is positive, the same "pseudorandom"
        sequence of numbers is returned, starting from a given seed value.
        Different number sequences will result from different seeds, but any
        sequence is repeatable by starting from the same seed number. Having a
        known sequence of "random" numbers is useful in testing programs.
      </p>
      <p>
        If you choose a &lt;numeric&gt; argument of zero, then RND generates a
        number directly from a free-running hardware clock (the system "jiffy
        clock"). Negative arguments cause the RND function to be re-seeded with
        each function call.
      </p>
      <b>EXAMPLES of RND Function:</b>
      <pre>
        <code class="language-basic">
          220 PRINT INT(RND(0)*50)               (Return random integers 0-49)
       
          100 X=INT(RND(1)*6)+INT(RND(1)*6)+2    (Simulates 2 dice)
       
          100 X=INT(RND(1)*1000)+1               (Random integers from 1-1000)
       
          100 X=INT(RND(1)*150)+100              (Random numbers from 100-249)
       
          100 X=RND(1)*(U-L)+L                   (Random numbers between
                                                  upper (U) and lower (L) limits)
        </code>
</pre>

      <h3><a name="run">RUN</a></h3>

      <b
        >TYPE: Command<br />
        FORMAT: RUN [&lt;line-number&gt;]</b
      >
      <p>
        <b>Action:</b> The system command RUN is used to start the program
        currently in memory. The RUN command causes an implied
        <a href="page_039.html#clr">CLR</a> operation to be performed before
        starting the program. You can avoid the
        <a href="page_039.html#clr">CLeaRing</a> operation by using
        <a href="page_041.html#cont">CONT</a> or
        <a href="page_052.html#goto">GOTO</a> to restart a program instead of
        RUN. If a &lt;line-number&gt; is specified, your program will start on
        that line. Otherwise, the RUN command starts at first line of the
        program. The RUN command can also be used within a program. If the
        &lt;line-number&gt; you specify doesn't exist, the BASIC error message
        <b
          ><a href="../Appendices/page_400.html#undef'd_statement"
            >UNDEF'D STATEMENT</a
          ></b
        >
        occurs.
      </p>
      <p>
        A RUNning program stops and BASIC returns to direct mode when an
        <a href="page_046.html#end">END</a> or
        <a href="page_086.html#stop">STOP</a> statement is reached, when the
        last line of the program is finished, or when a BASIC error occurs
        during execution.
      </p>

      <b>EXAMPLES of RUN Command:</b>
      <pre>
        <code class="language-basic">
          RUN           (Starts at first line of program)
       
          RUN 500       (Starts at line-number 500)
          RUN X         (Starts at line X, or UNDEF'D STATEMENT ERROR
                         if there is no line X)
        </code>
</pre>

      <h3><a name="save">SAVE</a></h3>

      <b
        >TYPE: Command<br />
        FORMAT: SAVE
        ["&lt;file-name&gt;"][,&lt;device-number&gt;][,&lt;address&gt;]</b
      >
      <p>
        <b>Action:</b> The SAVE command is used to store the program that is
        cur- rently in memory onto a tape or diskette file. The program being
        SAVEd is only affected by the command while the SAVE is happening. The
        program remains in the current computer memory even after the SAVE
        operation is completed until you put something else there by using
        another command. The file type will be "prg" (program). If the
        &lt;device-number&gt; is left out, then the C64 will automatically
        assume that you want the program saved on cassette, device number 1. If
        the &lt;device-number&gt; is an &lt;8&gt;, then the program is written
        onto disk. The SAVE statement can be used be used in your programs and
        execution will continue with the next statement after the SAVE is
        completed.
      </p>
      <p>
        Programs on tape are automatically stored twice, so that your Commodore
        64 can check for errors when
        <a href="page_059.html#load">LOADing</a> the program back in. When
        saving programs to tape, the &lt;file-name&gt; and secondary
        &lt;address&gt; are optional. But following a SAVE with a program name
        in quotes ("") or by a string variable (---$) helps your Commodore 64
        find each program more easily. If the file-name is left out it can NOT
        be <a href="page_059.html#load">LOADed</a> by name later on.
      </p>
      <p>
        A secondary address of I will tell the KERNAL to
        <a href="page_059.html#load">LOAD</a> the tape at a later time, with the
        program currently in memory instead of the normal 2048 location. A
        secondary address of 2 will cause an end-of-tape marker to follow the
        program. A secondary address of 3 combines both functions.
      </p>
      <p>
        When saving programs onto a disk, the &lt;file-name&gt; must be present.
      </p>
      <b>EXAMPLES of SAVE Command.</b>
      <pre>
        <code class="language-basic">
          SAVE               (Write to tape without a name)
       
          SAVE"ALPHA",1      (Store on tape as file-name "alpha")
       
          SAVE"ALPHA",1,2    (Store "alpha" with end-of-tape marker)
       
          SAVE"FUN.DISK",8   (SAVES on disk (device 8 is the disk))
       
          SAVE A$            (Store on tape with the name A$)
       
          10 SAVE"HI"        (SAVEs program and then move to next program line)
       
          SAVE"ME",1,3       (Stores at same memory location and puts an
                              end-of-tope marker on)
        </code>
</pre>

      <h3><a name="sgn">SGN</a></h3>

      <b
        >TYPE: Integer Function<br />
        FORMAT: SGN (&lt;numeric&gt;)</b
      >
      <p>
        <b>Action:</b> SGN gives you an integer value depending upon the sign of
        the &lt;numeric&gt; argument. If the argument is positive the result is
        1, if zero the result is also 0, if negative the result is -1.
      </p>

      <b>EXAMPLE of SGN Function:</b>
      <pre>
        <code class="language-basic">
          90 ON SGN(DV)+2 GOTO 100, 200, 300
          (jump to 100 if DV=negative, 200 if DV=0, 300 if DV=positive)
        </code>
</pre>

      <h3><a name="sin">SIN</a></h3>

      <b
        >TYPE: Floating-Point Function<br />
        FORMAT: SIN (&lt;numeric&gt;)</b
      >
      <p>
        <b>Action:</b> SIN gives you the sine of the &lt;numeric&gt; argument,
        in radians. The value of COS(X) is equal to SIN(x+3.14159265/2).
      </p>

      <b>EXAMPLE of SIN Function:</b>
      <pre>
        <code class="language-basic">
          235 AA=SIN(1.5):PRINT AA
          .997494987
        </code>
</pre>

      <h3><a name="spc">SPC</a></h3>

      <b
        >TYPE: String Function<br />
        FORMAT: SPC (&lt;numeric&gt;)</b
      >
      <p>
        <b>Action:</b> The SPC function is used to control the formatting of
        data, as either an output to the screen or into a logical file. The
        number of SPaCes given by the &lt;numeric&gt; argument are printed,
        starting at the first available position. For screen or tape files the
        value of the argument is in the range of 0 to 255 and for disk files up
        to 254. For printer files, an automatic carriage-return and line-feed
        will be performed by the printer if a SPaCe is printed in the last
        character position of a line. No SPaCes are printed on the following
        line.
      </p>

      <b>EXAMPLE of SPC Function:</b>
      <pre>
        <code class="language-basic">
          10 PRINT"RIGHT "; "HERE &amp;";
          20 PRINT SPC(5)"OVER" SPC(14)"THERE"
          RUN
          
          RIGHT HERE &amp;     OVER              THERE
        </code>
</pre>

      <h3><a name="sqr">SQR</a></h3>

      <b
        >TYPE: Floating-Point Function<br />
        FORMAT: SQR (&lt;numeric&gt;)</b
      >
      <p>
        <b>Action:</b> SQR gives you the value of the SQuare Root of the
        &lt;numeric&gt; argument. The value of the argument must not be
        negative, or the BASIC error message
        <b
          ><a href="../Appendices/page_400.html#illegal_quantity"
            >?ILLEGAL QUANTITY</a
          ></b
        >
        will happen.
      </p>

      <b>EXAMPLE of SQR Function:</b>
      <pre>
        <code class="language-basic">
          FOR J = 2 TO 5: PRINT J*S, SQR(J*5): NEXT
          
          10   3.16227766
          15   3.87298335
          20   4.47213595
          25   5
          
          READY
        </code>
</pre>

      <h3><a name="status">STATUS</a></h3>

      <b
        >TYPE: Integer Function<br />
        FORMAT: STATUS</b
      >
      <p>
        <b>Action:</b> Returns a completion STATUS for the last input/output
        operation which was performed on an open file. The STATUS can be read
        from any peripheral device. The STATUS (or simply ST) keyword is a
        system defined variable-name into which the KERNAL puts the STATUS of
        I/O operations. A table of STATUS code values for tape, printer, disk
        and RS-232 file operations is shown below:
      </p>

      <table align="center" border="1" cellspacing="0">
        <tr>
          <th>ST Bit Position</th>
          <th>ST Numeric Value</th>
          <th>Cassette Read</th>
          <th>Serial Bus R/W</th>
          <th>Tape Verify + Load</th>
        </tr>
        <tr>
          <td>0</td>
          <td>1</td>
          <td>&nbsp;</td>
          <td>time out write</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>1</td>
          <td>2</td>
          <td>&nbsp;</td>
          <td>time out read</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>2</td>
          <td>4</td>
          <td>short block</td>
          <td>&nbsp;</td>
          <td>short block</td>
        </tr>
        <tr>
          <td>3</td>
          <td>8</td>
          <td>long block</td>
          <td>&nbsp;</td>
          <td>long block</td>
        </tr>
        <tr>
          <td>4</td>
          <td>16</td>
          <td>unrecoverable read error</td>
          <td>&nbsp;</td>
          <td>any mismatch</td>
        </tr>
        <tr>
          <td>5</td>
          <td>32</td>
          <td>checksum error</td>
          <td>&nbsp;</td>
          <td>checksum error</td>
        </tr>
        <tr>
          <td>6</td>
          <td>64</td>
          <td>end of file</td>
          <td>EOI</td>
          <td>&nbsp;</td>
        </tr>
        <tr>
          <td>7</td>
          <td>-128</td>
          <td>end of tape</td>
          <td>device not present</td>
          <td>end of tape</td>
        </tr>
      </table>
      <b>EXAMPLES of STATUS Function:</b>
      <pre>
        <code class="language-basic">
          10 OPEN 1,4:OPEN 2,8,4,"MASTER FILE,SEQ,W"
          20 GOSUB 100:REM CHECK STATUS
          30 INPUT#2,A$,B,C
          40 IF STATUS AND 64 THEN 80:REM HANDLE END-OF-FILE
          50 GOSUB 100:REM CHECK STATUS
          60 PRINT#1,A$,B;C
          70 GOTO 20
          80 CLOSE1:CLOSE2
          90 GOSUB 100:END
          100 IF ST &gt; 0 THEN 9000:REM HANDLE FILE I/O ERROR
          110 RETURN
        </code>
</pre>

      <h3><a name="step">STEP</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: [STEP &lt;expression&gt;]</b
      >
      <p>
        <b>Action:</b> The optional STEP keyword follows the &lt;end-value&gt;
        expression in a <a href="page_047.html#for">FOR</a> statement. It
        defines an increment value for the loop counter variable. Any value can
        be used as the STEP increment. Of course, a STEP value of zero will loop
        forever. If the STEP keyword is left out, the increment value will be +
        1. When the <a href="page_062.html#next">NEXT</a> statement in a
        <a href="page_047.html#for">FOR</a> loop is reached, the STEP increment
        happens. Then the counter is tested against the end-value to see if the
        loop is finished. (See <a href="page_047.html#for">FOR</a> statement for
        more information.)
      </p>

      <table border="1" align="center" class="blue" cellspacing="0">
        <tr>
          <td>
            <b>NOTE:</b> The STEP value can NOT be changed once it's in the
            loop.
          </td>
        </tr>
      </table>

      <b>EXAMPLES of STEP Statement:</b>
      <pre>
        <code class="language-basic">
          25 FOR XX=2 TO 20 STEP 2             (Loop repeats 10 times)
          35 FOR ZZ=0 TO -20 STEP -2           (Loop repeats 11 times)
        </code>
</pre>

      <h3><a name="stop">STOP</a></h3>

      <b
        >TYPE: Statement<br />
        FORMAT: STOP</b
      >
      <p>
        <b>Action:</b> The STOP statement is used to halt execution of the
        current program and return to direct mode. Typing the
        <kbd>&lt;RUN/STOP&gt;</kbd> key on the keyboard has the same effect as a
        STOP statement. The BASIC error message
        <b
          ><a href="../Appendices/page_400.html#break"
            >?BREAK IN LINE nnnnn</a
          ></b
        >
        is displayed on the screen, followed by READY. The "nnnnn" is the
        line-number where the STOP occurs. Any open files remain open and all
        variables are preserved and can be examined. The program can be
        restarted by using <a href="page_041.html#cont">CONT</a> or
        <a href="page_052.html#goto">GOTO</a> statements.
      </p>

      <b>EXAMPLES of STOP Statement:</b>
      <pre>
        <code class="language-basic">
          10 INPUT#1,AA,BB,CC
          20 IF AA=BB AND BB=CC THEN STOP
          30 STOP
          (If the variable AA is -1 and BB is equal to CC then:)
          BREAK IN LINE 20
          BREAK IN LINE 30        (For any other data values)
        </code>
</pre>

      <h3><a name="str$">STR$</a></h3>

      <b>
        TYPE: String Function<br />
        FORMAT: STR$ (&lt;numeric&gt;)
      </b>

      <p>
        <b>Action:</b> STR$ gives you the STRing representation of the numeric
        value of the argument. When the STR$ value is converted to each variable
        represented in the &lt;numeric&gt; argument, any number shown is
        followed by a space and, if it's positive, it is also preceded by a
        space.
      </p>

      <b>EXAMPLE of STR$ Function:</b>
      <pre>
        <code class="language-basic">
          100 FLT = 1.5E4: ALPHA$ = STR$(FLT)
          110 PRINT FLT, ALPHA$
          
          15000     15000
        </code>
</pre>

      <h3><a name="sys">SYS</a></h3>

      <b>
        TYPE: Statement<br />
        FORMAT: SYS &lt;memory-location&gt;
      </b>

      <p>
        <b>Action:</b> This is the most common way to mix a BASIC program with a
        machine language program. The machine language program begins at the
        location given in the SYS statement. The system command SYS is used in
        either direct or program mode to transfer control of the microprocessor
        to an existing machine language program in memory. The memory-location
        given is by numeric expression and can be anywhere in memory, RAM or
        ROM. When you're using the SYS statement you must end that section of
        machine language code with an RTS (ReTurn from Subroutine) instruction
        so that when the machine language program is finished, the BASIC
        execution will resume with the statement following the SYS command.
      </p>

      <b>EXAMPLES of SYS Statement:</b>
      <table>
        <tr>
          <td><code>SYS 64738 </code></td>
          <td>(Jump to System Cold Start in ROM)</td>
        </tr>
        <tr>
          <td><code>10 POKE 4400,96:SYS 4400</code></td>
          <td>(Goes to machine code location 4400 and returns immediately)</td>
        </tr>
      </table>

      <h3><a name="tab">TAB</a></h3>

      <b>
        TYPE: String Function<br />
        FORMAT: TAB (&lt;numeric&gt;)
      </b>

      <p>
        <b>Action:</b> The TAB function moves the cursor to a relative
        <a href="page_083.html#spc">SPC</a> move position on the screen given by
        the &lt;numeric&gt; argument, starting with the left-most position of
        the current line. The value of the argument can range from 0 to 255. The
        TAB function should only be used with the
        <a href="page_070.html#print">PRINT</a> statement, since it has no
        effect if used with <a href="page_075.html#print">PRINT#</a> to a
        logical file.
      </p>

      <b>EXAMPLE of TAB Function:</b>
      <pre>
        <code class="language-basic">
          100 PRINT"NAME" TAB(25) "AMOUNT": PRINT
          110 INPUT#1, NAM$, AMT$
          120 PRINT NAM$ TAB(25) AMT$
          
          NAME                         AMOUNT
          
          
          G.T. JONES                   25.
        </code>
</pre>

      <h3><a name="tan">TAN</a></h3>

      <b>
        TYPE: Floating-Point Function<br />
        FORMAT: TAN (&lt;numeric&gt;)
      </b>
      <p>
        <b>Action:</b> Returns the tangent of the value of the &lt;numeric&gt;
        expression in radians. If the TAN function overflows, the BASIC error
        message
        <b
          ><a href="../Appendices/page_400.html#division_by_zero"
            >?DIVISION BY ZERO</a
          ></b
        >
        is displayed.
      </p>

      <b>EXAMPLE of TAN Function:</b>
      <pre>
        <code class="language-basic">
          10 XX=.785398163: YY=TAN(XX):PRINT YY
          
          1
        </code>
</pre>

      <h3><a name="time">TIME</a></h3>

      <b>
        TYPE: Numeric Function<br />
        FORMAT: TI
      </b>

      <p>
        <b>Action: </b>The TI function reads the interval Timer. This type of
        "clock" is called a "jiffy clock." The "jiffy clock" value is set at
        zero (initialized) when you power-up the system. This 1/60 second
        interval timer is turned off during tape I/O.
      </p>

      <b>EXAMPLE of TI Function:</b>
      <pre>
        <code class="language-basic">
          10 PRINT TI/60 "SECONDS SINCE POWER UP"
        </code>
</pre>

      <h3><a name="time$">TIME$</a></h3>

      <b>
        TYPE: String Function<br />
        FORMAT: TI$
      </b>
      <p>
        <b>Action: </b>The TI$ timer looks and works like a real clock as long
        as your system is powered-on. The hardware interval timer (or jiffy
        clock) is read and used to update the value of TI$, which will give you
        a TIme $tring of six characters in hours, minutes and seconds. The TI$
        timer can also be assigned an arbitrary starting point similar to the
        way you set your wristwatch. The value of TI$ is not accurate after tape
        I/O.
      </p>

      <b>EXAMPLE of TI$ Function:</b>
      <pre>
        <code class="language-basic">
          1 TI$ = "000000": FOR J=1 TO 10000: NEXT: PRINT TI$
          
          000011
        </code>
</pre>

      <h3><a name="usr">USR</a></h3>

      <b>
        TYPE: Floating-Point Function<br />
        FORMAT: USR (&lt;numeric&gt;)
      </b>

      <p>
        <b>Action: </b>The USR function jumps to a User callable machine
        language SubRoutine which has its starting address pointed to by the
        contents of memory locations 785-786. The starting address is
        established before calling the USR function by using
        <a href="page_069.html#poke">POKE</a> statements to set up locations
        785-786. Unless <a href="page_069.html#poke">POKE</a> statements are
        used, locations 785-786 will give you an
        <b
          ><a href="../Appendices/page_400.html#illegal_quantity"
            >?ILLEGAL QUANTITY</a
          ></b
        >
        error message.
      </p>
      <p>
        The value of the &lt;numeric&gt; argument is stored in the
        floating-point accumulator starting at location 97, for access by the
        Assembler code, and the result of the USR function is the value which
        ends up there when the subroutine returns to BASIC.
      </p>

      <b>EXAMPLES of USR Function:</b>
      <pre>
        <code class="language-basic">
          10 B=T*SIN(Y)
          20 C=USR(B/2)
          30 D=USR(B/3)
        </code>
</pre>

      <h3><a name="val">VAL</a></h3>

      <b>
        TYPE: Numeric Function<br />
        FORMAT: VAL (&lt;string&gt;)
      </b>
      <p>
        <b>Action: </b>Returns a numeric VALue representing the data in the
        &lt;string&gt; argument. If the first non-blank character of the string
        is not a plus sign (+), minus sign (-), or a digit the VALue returned is
        zero. String conversion is finished when the end of the string or any
        non-digit character is found (except decimal point or exponential e).
      </p>

      <b>EXAMPLE of VAL Function:</b>
      <pre>
        <code class="language-basic">
          10 INPUT#1, NAM$, ZIP$
          20 IF VAL(ZIP$) &lt; 19400 OR VAL(ZIP$) &gt; 96699
          THEN PRINT NAM$ TAB(25) "GREATER PHILADELPHIA"
        </code>
</pre>

      <h3><a name="verify">VERIFY</a></h3>

      <b>
        TYPE: Command<br />
        FORMAT: VERIFY ["&lt;file-name&gt;"][,&lt;device&gt;]
      </b>

      <p>
        <b>Action: </b>The VERIFY command is used, in direct or program mode, to
        compare the contents of a BASIC program file on tape or disk with the
        program currently in memory. VERIFY is normally used right after a
        <a href="page_081.html#save">SAVE</a>, to make sure that the program was
        stored correctly on tape or disk.
      </p>
      <p>
        If the &lt;device&gt; number is left out, the program is assumed to be
        on the Datassette<sup><small>TM</small></sup> which is device number 1.
        For tape files, if the &lt;file-name&gt; is left out, the next program
        found on the tape will be compared. For disk files (device number 8),
        the file-name must be present. If any differences in program text are
        found, the BASIC error message
        <b><a href="../Appendices/page_400.html#verify">?VERIFY ERROR</a></b> is
        displayed.
      </p>
      <p>
        A program name can be given either in quotes (" ") or as a string
        variable. VERIFY is also used to position a tape just past the last
        program, so that a new program can be added to the tape without
        accidentally writing over another program.
      </p>

      <b>EXAMPLES of VERIFY Command:</b>
      <pre>
        <code class="language-basic">
          VERIFY                      (Checks 1st program on tape)
          PRESS PLAY ON TAPE
          OK
          SEARCHING
          FOUND &lt;FILENAME&gt;
          VERIFYING
          
          9000 SAVE "ME",8:
          9010 VERIFY "ME",8          (Looks at device 8 for the program)
        </code>
</pre>

      <h3><a name="wait">WAIT</a></h3>
      <b>
        TYPE: Statement<br />
        FORMAT: WAIT &lt;location&gt;,&lt;mask-1&gt;[,&lt;mask-2&gt;]
      </b>
      <p>
        <b>Action: </b>The WAIT statement causes program execution to be
        suspended until a given memory address recognizes a specified bit
        pattern. In other words WAIT can be used to halt the program until some
        external event has occurred. This is done by monitoring the status of
        bits in the input/ output registers, The data items used with WAIT can
        be any numeric expressions, but they will be converted to integer
        values. For most programmers, this statement should never be used. It
        causes the program to halt until a specific memory location's bits
        change in a specific way. This is used for certain I/O operations and
        almost nothing else.
      </p>
      <p>
        The WAIT statement takes the value in the memory location and performs a
        logical <a href="page_035.html#and">AND</a> operation with the value in
        mask-1. If there is a mask-2 in the statement, the result of the first
        operation is exclusive-ORed with mask-2. In other words mask-1 "filters
        out" any bits that you don't want to test. Where the bit is 0 in mask-1,
        the corresponding bit in the result will always be 0. The mask-2 value
        flips any bits, so that you can test for an off condition as well as an
        on condition, Any bits being tested for a 0 should have a I in the
        corresponding position in mask-2.
      </p>
      <p>
        If corresponding bits of the &lt;mask-1&gt; and &lt;mask-2&gt; operands
        differ, the exclusive-OR operation gives a bit result of 1. If
        corresponding bits get the same result the bit is 0. It is possible to
        enter an infinite pause with the WAIT statement, in which case the
        <kbd>&lt;RUN/STOP&gt;</kbd> and <kbd>&lt;RESTORE&gt;</kbd> keys can be
        used to recover. Hold down the <kbd>&lt;RUN/STOP&gt;</kbd> key and then
        press <kbd>&lt;RESTORE&gt;</kbd>. The first example below WAITs until a
        key is pressed on the tape unit to continue with the program. The second
        example will WAIT until a sprite collides with the screen background.
      </p>

      <b> EXAMPLES of WAIT Statement:</b>
      <pre>
        <code class="language-basic">
          WAIT 1,32,32
          WAIT 53273,6,6
          WAIT 36868,144,16</code>         
          
          (144 &amp; 16 are masks. 144=10010000 in binary
          and 16=10000 in binary. The WAIT statement
          will halt the program until the 128 bit is
          on or until the 16 bit is off)
</pre>

      <h2><a name="Keyboard">THE COMMODORE 64 KEYBOARD AND FEATURES</a></h2>

      <p>
        The Operating System has a ton-character keyboard "buffer" that is used
        to hold incoming keystrokes until they can be processed. This buffer, or
        queue, holds keystrokes in the order in which they occur so that the
        first one put into the queue is the first one processed. For example, if
        a second keystroke occurs before the first can be processed, the second
        character Is stored in the buffer, while processing of the first
        character continues. After the program has finished with the first
        character, the keyboard buffer is examined for more data, and the second
        keystroke processed. Without this buffer, rapid keyboard input would
        occasionally drop characters.
      </p>
      <p>
        In other words, the keyboard buffer allows you to "type-ahead" of the
        system, which means it can anticipate responses to
        <a href="page_054.html#input">INPUT</a> prompts or
        <a href="page_049.html#get">GET</a> statements. As you type on the keys
        their character values are lined up, single-file (queued) into the
        buffer to wait for processing in the order the keys were struck. This
        type-ahead feature can give you an occasional problem where an
        accidental keystroke causes a program to fetch an incorrect character
        from the buffer.
      </p>
      <p>
        Normally, incorrect keystrokes present no problem, since they can be
        corrected by the CuRSoR-Left <kbd>&lt;CRSR LEFT&gt;</kbd> or DELete
        <kbd>&lt;INST/DEL&gt;</kbd> keys and then retyping the character, and
        the corrections will be processed before a following carriage-return.
        However, if you press the <kbd>&lt;RETURN&gt;</kbd> key, no corrective
        action is possible, since all characters in the buffer up to and
        including the carriage-return will be processed before any corrections.
        This situation can be avoided by using a loop to empty the keyboard
        buffer before reading an intended response:
      </p>
      <pre>
   10 GET JUNK$: IF JUNK$ &lt;&gt;"" THEN 10: REM EMPTY THE KEYBOARD BUFFER
</pre
      >
      <p>
        In addition to <a href="page_049.html#get">GET</a> and
        <a href="page_054.html#input">INPUT</a>, the keyboard can also be read
        using <a href="page_069.html#peek">PEEK</a> to fetch from memory
        location 197 ($00C5) the integer value of the key currently being
        pressed. If no key Is being held when the
        <a href="page_069.html#peek">PEEK</a> is executed, a value of 64 is
        returned, The numeric keyboard values, keyboard symbols and character
        equivalents (<a href="page_038.html#chr$">CHR$</a>) are shown in
        Appendix C. The following example loops until a key is pressed then
        converts the integer to a character value.
      </p>
      <pre>
        <code class="language-basic">
          10 AA=PEEK(197): IF AA=64 THEN 10
          20 BB$=CHR$(AA)
        </code>
</pre>

      <p>
        The keyboard is treated as a set of switches organized into a matrix of
        8 columns by 8 rows. The keyboard matrix is scanned for key switch-
        closures by the KERNAL using the CIA #1 I/O chip (MOS 6526 Complex
        Interface Adapter). Two CIA registers are used to perform the scan:
        register #0 at location 56320 ($DC00) for keyboard columns and register
        #l at location 56321 ($DC01) for keyboard rows.
      </p>
      <p>
        Bits 0-7 of memory location 56320 correspond to the columns 0-7. Bits
        0-7 of memory location 56321 correspond to rows 0-7. By writing column
        values in sequence, then reading row values, the KERNAL decodes the
        switch closures into the <a href="page_038.html#chr$">CHR$ (N)</a> value
        of the key pressed.
      </p>
      <p>
        Eight columns by eight rows yields 64 possible values. However, if you
        first strike the <kbd>&lt;RVS ON&gt;</kbd>, <kbd>&lt;CTRL&gt;</kbd> or
        <kbd>&lt;C=&gt;</kbd> keys or hold down the <kbd>&lt;SHIFT&gt;</kbd> key
        and type a second character, additional values are generated. This is
        because the KERNAL decodes these keys separately and "remembers" when
        one of the control keys was pressed. The result of the keyboard scan is
        then placed in location 197.
      </p>
      <p>
        Characters can also be written directly to the keyboard buffer at
        locations 631-640 using a
        <a href="page_069.html#poke">POKE</a> statement. These characters will
        be processed when the <a href="page_069.html#poke">POKE</a> is used to
        set a character count into location 198. These facts can be used to
        cause a series of direct-mode commands to be executed automatically by
        printing the statements onto the screen, putting carriage-returns into
        the buffer, and then setting the character count. In the example below,
        the program will <a href="page_058.html#list">LIST</a> itself to the
        printer and then resume execution.
      </p>
      <pre>
        <code class="language-basic">
          10 PRINT CHR$(147)"PRINT#1: CLOSE 1: GOTO 50"
          20 POKE 631119: POKE 632,13: POKE 633,13: POKE 198,3
          30 OPEN 114: CMD1: LIST
          40 END
          50 REM PROGRAM RE-STARTS HERE
        </code>
</pre>

      <h2><a name="Editor">SCREEN EDITOR</a></h2>

      <p>
        The SCREEN EDITOR provides you with powerful and convenient facilities
        for editing program text. Once a section of a program is listed to the
        screen, the cursor keys and other special keys are used to move around
        the screen so that you can make any appropriate changes. After making
        all the changes you want to a specific line-number of text, hitting the
        <kbd>&lt;RETURN&gt;</kbd> key anywhere on the line, causes the SCREEN
        EDITOR to read the entire 80-character logical screen line.
      </p>

      <p>
        The text is then passed to the Interpreter to be tokenized and stored in
        the program. The edited line replaces the old version of that line in
        memory. An additional copy of any line of text can be created simply by
        changing the line-number and pressing <kbd>&lt;RETURN&gt;</kbd>.
      </p>
      <p>
        If you use keyword abbreviations which cause a program line to exceed 80
        characters, the excess characters will be lost when that line is edited,
        because the EDITOR will read only two physical screen lines. This is
        also why using <a href="page_054.html#input">INPUT</a> for more than a
        total of 80 characters is not possible. Thus, for all practical
        purposes, the length of a line of BASIC text is limited to 80 characters
        as displayed on the screen.
      </p>
      <p>
        Under certain conditions the SCREEN EDITOR treats the cursor control
        keys differently from their normal mode of handling. If the CuRSoR is
        positioned to the right of an odd number of double-quote marks (") the
        EDITOR operates in what is known as the QUOTE-MODE.
      </p>
      <p>
        In quote mode data characters are entered normally but the cursor
        controls no longer move the CuRSoR, instead reversed characters are
        displayed which actually stand for the cursor control being entered. The
        same is true of the color control keys. This allows you to include
        cursor and color controls inside string data items in programs. You will
        find that this is a very important and powerful feature. That's because
        when the text inside the quotes is printed to the screen it performs the
        cursor positioning and color control functions automatically as part of
        the string. An example of using cursor controls in strings is:
      </p>
      <pre>
        <code class="language-basic">
          You type --&gt;         10 PRINT"A(R)(R)B(L)(L)(L)C(R)(R)D": REM(R)=CRSR
          RIGHT, (L)=CRSR LEFT
          
          Computer prints --&gt;  AC BD
        </code>
   
  </pre>
      <p>
        The <kbd>&lt;DEL&gt;</kbd> key is the only cursor control NOT affected
        by quote mode. Therefore, if an error is made while keying in quote
        mode, the <kbd>&lt;CRSR LEFT&gt;</kbd> key can't be used to back up and
        strike over the error - even the <kbd>&lt;INST&gt;</kbd> key produces a
        reverse video character. Instead, finish entering the line, and then,
        after hitting the <kbd>&lt;RETURN&gt;</kbd> key, you can edit the line
        normally. Another alternative, if no further cursor-controls are needed
        in the string, is to press the <kbd>&lt;RUN/STOP&gt;</kbd> and
        <kbd>&lt;RESTORE&gt;</kbd> keys which will cancel QUOTE MODE. The cursor
        control keys that you can use in strings are shown in
        <a href="page_096.html#2-2">Table 2-2</a>.
      </p>

      <p></p>
      <table align="center">
        <caption>
          <a name="2-2">Table 2-2. Cursor Control Characters in QUOTE MODE</a>
        </caption>
        <tr>
          <th>Control Key</th>
          <th>Appearance</th>
        </tr>
        <tr>
          <td><kbd>&lt;CRSR UP&gt;</kbd></td>
          <td></td>
        </tr>
        <tr>
          <td><kbd>&lt;CRSR DOWN&gt;</kbd></td>
          <td></td>
        </tr>
        <tr>
          <td><kbd>&lt;CRSR LEFT&gt;</kbd></td>
          <td></td>
        </tr>
        <tr>
          <td><kbd>&lt;CRSR RIGHT&gt;</kbd></td>
          <td></td>
        </tr>
        <tr>
          <td><kbd>&lt;CLR&gt;</kbd></td>
          <td></td>
        </tr>
        <tr>
          <td><kbd>&lt;HOME&gt;</kbd></td>
          <td></td>
        </tr>
        <tr>
          <td><kbd>&lt;INST&gt;</kbd></td>
          <td></td>
        </tr>
      </table>
      <p>
        When you are NOT in quote mode, holding down the
        <kbd>&lt;SHIFT&gt;</kbd> key and then pressing the INSerT
        <kbd>&lt;INST&gt;</kbd> key shifts data to the right of the cursor to
        open up space between two characters for entering data between them. The
        Editor then begins operating in INSERT MODE until all of the space
        opened up is filled.
      </p>
      <p>
        The cursor controls and color controls again show as reversed characters
        in insert mode. The only difference occurs on the DELete and INSerT
        <kbd>&lt;INST/DEL&gt;</kbd> key. The <kbd>&lt;DEL&gt;</kbd> instead of
        operating normally as in the quote mode, now creates the reversed T. The
        <kbd>&lt;INST&gt;</kbd> key, which created a reverse character in quote
        mode, inserts spaces normally.
      </p>
      <p>
        This means that a <a href="page_070.html#print">PRINT</a> statement can
        be created, containing DELetes, which can't be done in quote mode. The
        insert mode is cancelled by pressing the <kbd>&lt;RETURN&gt;</kbd>,
        <kbd>&lt;SHIFT&gt;</kbd> and
        <kbd>&lt;RETURN&gt;, or &lt;RUN/STOP&gt;</kbd> and
        <kbd>&lt;RESTORE&gt;</kbd> keys. Or you can cancel the insert mode by
        filling all the inserted spaces. An example of using DEL characters in
        strings is:
      </p>
      <pre>
        <code class="language-basic">
          10 PRINT"HELLO"&lt;DEL&gt;&lt;INST&gt;&lt;INST&gt;&lt;DEL&gt;&lt;DEL&gt;P"
          (Keystroke sequence shown above, appearance when listed below)
          10 PRINT"HELP"
        </code>
      </pre>
      <p>
        When the example is <a href="page_081.html#run">RUN</a>, the word
        displayed will be HELP, because the letters LO are deleted before the P
        is printed. The DELete character in strings will work with
        <a href="page_058.html#list">LIST</a> as well as
        <a href="../Chapter_2/page_081.html#run">RUN</a>. You can use this to
        "hide" part or all of a line of text using this technique. However,
        trying to edit a line with these characters will be difficult if not
        impossible.
      </p>

      <p>
        There are some other characters that can be printed for special
        functions, although they are not easily available from the keyboard. In
        order to get these into quotes, you must leave empty spaces for them in
        the line, press <kbd>&lt;RETURN&gt;</kbd>, and go back to edit the line.
        Now you hold down the <kbd>&lt;CTRL&gt;</kbd> (ConTRoL) key and type
        <kbd>&lt;RVS ON&gt;</kbd> (ReVerSe-ON) to start typing reversed
        characters. Type the keys as shown below:
      </p>

      <table align="center">
        <tr>
          <th>Key Function</th>
          <th>Key Entered</th>
          <th>Appearance</th>
        </tr>
        <tr>
          <td>Shifted RETURN</td>
          <td><kbd>&lt;SHIFT+M&gt;</kbd></td>
          <td></td>
        </tr>
        <tr>
          <td>Switch to upper/lower case</td>
          <td><kbd>&lt;N&gt;</kbd></td>
          <td></td>
        </tr>
        <tr>
          <td>Switch to upper/graphics</td>
          <td><kbd>&lt;SHIFT+N&gt;</kbd></td>
          <td></td>
        </tr>
      </table>

      <p>
        Holding down the <kbd>&lt;SHIFT&gt;</kbd> key and hitting
        <kbd>&lt;RETURN&gt;</kbd> causes a carriage-return and line-feed on the
        screen but does not end the string. This works with
        <a href="page_058.html#list">LIST</a> as well as
        <a href="page_070.html#print">PRINT</a>, so editing will be almost
        impossible if this character is used. When output is switched to the
        printer via the CMD statement, the reverse "N" character shifts the
        printer into its upper-lower case character set and the
        <kbd>&lt;SHIFT&gt;</kbd> "N" shifts the printer into the
        upper-case/graphics character set.
      </p>
      <p>
        Reverse video characters can be included in strings by holding down the
        ConTRoL <kbd>&lt;CTRL&gt;</kbd> key and pressing ReVerSe
        <kbd>&lt;RVS&gt;</kbd>, causing a reversed R to appear inside the
        quotes. This will make all characters print in reverse video (like a
        negative of a photograph). To end the reverse printing, press
        <kbd>&lt;CTRL&gt;</kbd> and <kbd>&lt;RVS OFF&gt;</kbd> (ReVerSe OFF) by
        holding down the <kbd>&lt;CTRL&gt;</kbd> key and typing the
        <kbd>&lt;RVS OFF&gt;</kbd> key, which prints a reverse R. Numeric data
        can be printed in reverse video by first printing a
        <a href="../Chapter_2/page_038.html#chr$">CHR$(18)</a>. Printing a
        <a href="../Chapter_2/page_038.html#chr$">CHR$(146)</a> or a
        carriage-return will cancel reverse video output.
      </p>
    </div>
    <script src="js/prism.js"></script>
    <script src="js/jquery-3.4.1.js"></script>
  </body>
</html>
